// SableCC grammar for Dependent Artifact Build Language (DABL).
// For SableCC info, see http://www.sablecc.org/
// For a good SableCC reference, see http://www.natpryce.com/articles/000531.html


Package scaledmarkets.dabl.task;


Helpers

    any_character = [0x0 .. 0xfffff];
    tab   = 9;
    cr    = 13;
    nl    = 10;
    dollar = '$';
    comma = ',';
    blank = ' ';
    lcletter = ['a' .. 'z'];
    ucletter = ['A' .. 'Z'];
    underscore = '_';
    letter = (lcletter | ucletter | underscore);
    digit = ['0' .. '9'];
    escape = '%' digit digit;
    quote = '"';
    triplequote = '"""';
    slashslash = '//';
    slashslashslash = '///';
    slashstar = '/*';
    starslash = '*/';
    slashslashstar = '//*';
    starslashslash = '*//';
    linetermination = (cr nl | nl);
    per = '.';


Tokens

    // Punctuation:
    tab_char = tab;
    nl_char = nl;
    comma_char = comma;
    plus = '+';
    dash = '-';
    asterisk = '*';
    div = '/';
    gt = '>';
    lt = '<';
    ge = '>=';
    le = '<=';
    eq = '=';
    ne = '!=';
    gets = '<-';
    colon = ':';
    semicolon = ';';
    dotdot = '..';
    qmark = '?';
    def = 'def';
    left_paren = '(';
    right_paren = ')';
    left_cur = '{';
    right_cur = '}';
    left_brack = '[';
    right_brack = ']';
    per_char = per;
    caret = '^';
    
    // Propositional Keywords:
    from = 'from';
    to = 'to';
    in = 'in';
    for = 'for';
    with = 'with';
    when = 'when';
    on = 'on';
    of = 'of';
    than = 'than';
    
    // Non-Propositional Keywords:
    namespace = 'namespace';
    import = 'import';
    tab_keyword = 'tab';
    equivalent = 'equivalent';
    spaces_keyword = 'spaces';
    artifact = 'artifact';
    task = 'task';
    public = 'public';
    repo = 'repo';
    type = 'type';
    git = 'git';
    //maven = 'maven';
    //svn = 'svn';
    files = 'files';
    shell = 'shell';
    translation = 'translation';
    translate = 'translate';
    filename = 'filename';
    prefer = 'prefer';
    latest = 'latest';
    assume = 'assume';
    compatible = 'compatible';
    tested = 'tested';
    function = 'function';
    binds = 'binds';
    method = 'method';
    returns = 'returns';
    succeeded = 'succeeded';
    failed = 'failed';
    newer = 'newer';
    older = 'older';
    inputs = 'inputs';
    outputs = 'outputs';
    path_keyword = 'path';
    scheme = 'scheme';
    if = 'if';
    end = 'end';
    error = 'error';
    string_keyword = 'string';
    int_keyword = 'int';
    float_keyword = 'float';
    boolean_keyword = 'boolean';
    not_keyword = 'not';
    and_keyword = 'and';
    or_keyword = 'or';
    include = 'include';
    exclude = 'exclude';
    true_keyword = 'true';
    false_keyword = 'false';
    userid = 'userid';
    password = 'password';
    new = 'new';
    local = 'local';
    open = 'open';

    // Variable Length Sequences:
    whole_number = digit+;
    whitespace = (blank | cr | nl | tab )+;
    id = ( letter | underscore ) ( letter | digit | underscore )+;
    string = quote [ any_character - quote ]* quote;
    string2 = triplequote any_character* triplequote;
    slashslashcomment = slashslash [ any_character - nl ]* nl;
    slashslashslashcomment = slashslashslash [ any_character - nl ]* nl;
    slashstarcomment = slashstar any_character* starslash;
    slashslashstarcomment = slashslashstar any_character* starslashslash;
    

Ignored Tokens

    slashslashcomment,
    slashslashslashcomment,
    slashstarcomment,
    slashslashstarcomment,
    whitespace;


// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
Productions

    program {-> oprogram} =
        function_decls_opt                  {->
      | procedural_stmts_opt                {-> New oprogram([procedural_stmts_opt.oproc_stmt])}
        ;
    
    procedural_stmts_opt {-> oproc_stmt*} =
        {multiple} procedural_stmts         {-> [procedural_stmts.oproc_stmt]}
      | {none}                              {-> []}
      ;
    
    procedural_stmts {-> oproc_stmt*} =
        {multiple} procedural_stmts procedural_stmt
                                            {-> [procedural_stmts.oproc_stmt,
                                                procedural_stmt.oproc_stmt]}
      | {one} procedural_stmt               {-> [procedural_stmt.oproc_stmt]}
      ;
      
    procedural_stmt {-> oproc_stmt} =
        {func_call} func_call_stmt          {-> func_call_stmt.oproc_stmt}
      | {if_error} if_error_stmt            {-> if_error_stmt.oproc_stmt}
      ;
    
    func_call_stmt {-> oproc_stmt} =
        {no_target} [target]:id gets [func_name]:id args
                                            {-> New oproc_stmt.func_call(
                                                New oid_ref(func_name),
                                                [args.oexpr], New otarget_opt.target(target))}
      | {target} [func_name]:id args
                                            {-> New oproc_stmt.func_call(
                                                New oid_ref(func_name),
                                                [args.oexpr], New otarget_opt.no_target())}
        ;
    
    args {-> oexpr*} =
        {multiple_args} arg arg_separator args
                                            {-> [arg.oexpr, args.oexpr]}
      | {one_arg} arg                       {-> [arg.oexpr]}
      ;
    
    arg_separator {-> otype_spec_separator} =
        {comma} comma_char                  {-> New otype_spec_separator.comma()}
      | {prep} preposition                  {-> New otype_spec_separator.preposition(
                                                  preposition.opreposition)}
      ;
    
    arg {-> oexpr} =
        expr                                {-> expr.oexpr}
        ;
    
    if_error_stmt {-> oproc_stmt} =
        [a]:if error procedural_stmts end [b]:if
                                            {-> New oproc_stmt.if_error(
                                                [procedural_stmts.oproc_stmt])}
        ;
    
    scope_decl {-> oscope} =
        {public} public                     {-> New oscope.public()}
      | {unspecified}                       {-> New oscope.private()}
      ;
    
    function_decls_opt {-> ofunction_declaration*} =
        {multiple} function_decls           {-> [function_decls.ofunction_declaration]}
      | {none}                              {-> []}
      ;
    
    function_decls {-> ofunction_declaration*} =
        {multiple} function_decls function_decl
                                            {-> [function_decls.ofunction_declaration,
                                                function_decl.ofunction_declaration]}
      | {one} function_decl                 {-> [function_decl.ofunction_declaration]}
      ;
    
    function_decl {-> ofunction_declaration} =
        scope_decl function [dabl_name]:id type_spec_seq binds to [target_language]:string_literal
            method [native_name]:string_literal returns type_spec
                                            {-> New ofunction_declaration(scope_decl.oscope,
                                                    dabl_name, [type_spec_seq.otype_spec],
                                                    native_language.ostring_literal,
                                                    native_name.ostring_literal,
                                                    type_spec.otype_spec)}
        ;
    
    type_spec_seq {-> otype_spec*} =
        {multiple} type_spec type_spec_separator type_spec_seq
                                            {-> [type_spec.otype_spec,
                                                New otype_spec.separator(type_spec_separator.otype_spec_separator),
                                                type_spec_seq.otype_spec]}
      | {one} type_spec                     {-> [type_spec.otype_spec]}
      ;
    
    type_spec_separator {-> otype_spec_separator} =
        {comma} comma_char                  {-> New otype_spec_separator.comma()}
      | {preposition} preposition  // for defining a keyword that goes before or after a function arg
                                            {-> New otype_spec_separator.preposition(
                                                  preposition.opreposition)}
      ;
    
    preposition {-> opreposition} =
        {from} from                         {-> New opreposition.from()}
      | {to} to                             {-> New opreposition.to()}
      | {in} in                             {-> New opreposition.in()}
      | {for} for                           {-> New opreposition.for()}
      | {with} with                         {-> New opreposition.with()}
      | {when} when                         {-> New opreposition.when()}
      | {on} on                             {-> New opreposition.on()}
      | {of} of                             {-> New opreposition.of()}
      | {than} than                         {-> New opreposition.than()}
      ;
    
    type_spec {-> otype_spec} = 
        {string} string_keyword             {-> New otype_spec.string()}
      | {int} int_keyword                   {-> New otype_spec.int()}
      | {float} float_keyword               {-> New otype_spec.float()}
      | {boolean} boolean_keyword           {-> New otype_spec.logical()}
      ;
    
    path {-> id*} =
        {multiple} id per_char path         {-> [id, path.id]}
      | {one} id                            {-> [id]}
      ;

    
    // Expressions.
    
    expr {-> oexpr} =
        {logical} logical_expr              {-> logical_expr.oexpr}
      | {numeric} numeric_expr              {-> numeric_expr.oexpr}
      | {logical_term} logical_term         {-> logical_term.oexpr}
      | {value} value                       {-> value.oexpr}
      ;
    
    value {-> oexpr} =
        {value} literal                     {-> New oexpr.literal(literal.oliteral)}
      | {variable} id                       {-> New oexpr.variable(New ovariable(New oid_ref(id)))}
      | {parentheses} left_paren expr right_paren
                                            {-> expr.oexpr}
      ;
    
    // Logical expressions.
    
    logical_expr {-> oexpr} =
        {many} [left]:expr logical_operator [right]:logical_term_or_value
                                            {-> New oexpr.binary(
                                                left.oexpr, logical_operator.obinary_op,
                                                right.oexpr)}
        ;
    
    logical_operator {-> obinary_op} =
        {and} and_keyword                   {-> New obinary_op.and()}
      | {or} or_keyword                     {-> New obinary_op.or()}
      | {gt} gt                             {-> New obinary_op.gt()}
      | {lt} lt                             {-> New obinary_op.lt()}
      | {ge} ge                             {-> New obinary_op.ge()}
      | {le} le                             {-> New obinary_op.le()}
      | {eq} eq                             {-> New obinary_op.eq()}
      | {ne} ne                             {-> New obinary_op.ne()}
      ;
    
    logical_term {-> oexpr} =
        {not} not_expr                      {-> not_expr.oexpr}
      ;
    
    logical_term_or_value {-> oexpr} =
        {term} logical_term                 {-> logical_term.oexpr}
      | {value} value                       {-> value.oexpr}
      ;
    
    not_expr {-> oexpr} =
        not_keyword value                   {-> New oexpr.unary(New ounary_op.negation(),
                                                value.oexpr)}
        ;
    
    // Arithmetic expressions.
    
    numeric_expr {-> oexpr} =
        {many} expr add_op product_or_value  {-> New oexpr.binary(
                                                expr.oexpr,
                                                add_op.obinary_op, product_or_value.oexpr)}
      | {one} product                       {-> product.oexpr}
      ;
    
    product_or_value {-> oexpr} =
        {product} product                   {-> product.oexpr}
      | {value} value                       {-> value.oexpr}
      ;
    
    product {-> oexpr} =
        {many} product mult_op value        {-> New oexpr.binary(
                                                product.oexpr, mult_op.obinary_op,
                                                value.oexpr)}
      ;
    
    add_op {-> obinary_op} =
        {addition} plus                     {-> New obinary_op.plus()}
      | {subtraction} dash                  {-> New obinary_op.minus()}
      ;
    
    mult_op {-> obinary_op} =
        {multiplication} asterisk           {-> New obinary_op.multiply()}
      | {division} div                      {-> New obinary_op.divide()}
      ;
    
    // Literals.
    
    literal {-> oliteral} =
        {logic} logical_literal             {-> New oliteral.logic(logical_literal.ologic_literal)}
      | {string} string_literal             {-> New oliteral.string(string_literal.ostring_literal)}
      | {numeric} numeric_literal           {-> New oliteral.numeric(numeric_literal.onumeric_literal)}
      ;
    
    logical_literal {-> ologic_literal} =
        {true} true_keyword                 {-> New ologic_literal.true()}
      | {false} false_keyword               {-> New ologic_literal.false()}
      ;
    
    numeric_literal {-> onumeric_literal} =
        {int} sign_opt whole_number         {-> New onumeric_literal.int(sign_opt.osign, whole_number)}
      | {numeric_pattern} sign_opt num_slot fraction_seq
                                            {-> New onumeric_literal.pattern(
                                                sign_opt.osign, num_slot.onum_slot,
                                                [fraction_seq.onum_slot])}
      ;
    
    sign_opt {-> osign} =
        {pos} plus                          {-> New osign.positive()}
      | {neg} dash                          {-> New osign.negative()}
      |                                     {-> New osign.positive()}
      ;
    
    fraction_seq {-> onum_slot*} =
        {many} fraction fraction_seq        {-> [fraction.onum_slot, fraction_seq.onum_slot]}
      | {one} fraction                      {-> [fraction.onum_slot]}
      ;
      
    fraction {-> onum_slot} =
        per_char num_slot                   {-> num_slot.onum_slot}
        ;
    
    num_slot {-> onum_slot} =
        {num} whole_number                  {-> New onum_slot.num(whole_number)}
      | {wildcard} asterisk                 {-> New onum_slot.wildcard()}
      ;
    
    string_literal {-> ostring_literal} =
        {str} string_value                  {-> string_value.ostring_literal}
      | {strex} static_str_expr             {-> static_str_expr.ostring_literal}
//      | {non_ws} non_ws_char_seq  // this can be a path that references a variable
//                                          {-> New ostring_literal.charseq(non_ws_char_seq)}
      ;
    
    static_str_expr {-> ostring_literal} =
        {expr} [left]:string_literal caret [right]:string_value
                                            {-> New ostring_literal.static_string_expr(
                                                  left.ostring_literal, right.ostring_literal)}
        ;
    
    string_value {-> ostring_literal} =
        {string} string                     {-> New ostring_literal.string(string)}
      | {string2} string2                   {-> New ostring_literal.string2(string2)}
      ;


// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
Abstract Syntax Tree

    oprogram =
        oproc_stmt*
        ;
    
    oid_ref =
        id
        ;
    
    oqualified_name_ref =
        id*
        ;
    
    ostring_value_opt =
        {specified} ostring_literal
      | {unspecified}
      ;
    
    ofunction_declaration =
        oscope [name]:id otype_spec* [native_language]:ostring_literal [native_name]:ostring_literal
            [return_type]:otype_spec;

    otype_spec = 
        {string}
      | {int}
      | {float}
      | {logical}
      | {separator} otype_spec_separator
      ;
    
    otype_spec_separator =
        {comma}
      | {preposition} opreposition
      ;

    opreposition =
        {from}
      | {to}
      | {in}
      | {for}
      | {with}
      | {when}
      | {on}
      | {of}
      | {than}
      ;
    
    oscope =
        {public}
      | {private}
      ;
    
    oproc_stmt =
        {func_call} oid_ref oexpr* otarget_opt
      | {if_error} oproc_stmt*
      ;
    
    otarget_opt =
        {target} id
      | {no_target}
      ;
    
    // Expressions.
    
    ounary_op =
        {negation}
        ;
    
    obinary_op =
        {plus}
      | {minus}
      | {multiply}
      | {divide}
      | {and}
      | {or}
      | {gt}
      | {lt}
      | {ge}
      | {le}
      | {eq}
      | {ne}
      ;
    
    oexpr =
        {literal} oliteral
      | {variable} ovariable
      | {unary} ounary_op oexpr
      | {binary} [operand1]:oexpr obinary_op [operand2]:oexpr
      ;
    
    oliteral =
        {logic} ologic_literal
      | {string} ostring_literal
      | {numeric} onumeric_literal
      ;
    
    ovariable =
        oid_ref
        ;
    
    ologic_literal =
        {true}
      | {false}
      ;
    
    ostring_literal =
        {string} string
      | {string2} string2
      | {static_string_expr} [left]:ostring_literal [right]:ostring_literal
      ;
    
    onumeric_literal =
        {int} osign whole_number
      | {pattern} osign [magnitude]:onum_slot [mantissa]:onum_slot*
        ;

    onum_slot =
        {num} whole_number
      | {wildcard}
      ;

    osign =
        {positive}
      | {negative}
      ;