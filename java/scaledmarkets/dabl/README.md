# Compiler Design

## Template Processor

TBD


## Main Program Top Level Structure

![Figure 1: Main Program Top Level Structure](MainProgram.png "Figure 1: Main Program Top Level Structure")

The <code>scaledmarkets.dabl.parser.Parser</code> class parses input and builds an
Abstract Syntax Tree (AST). The language grammar and the AST structure are
both defined in the DABL language grammar spec,
[`dabl.sablecc`](https://github.com/Scaled-Markets/dabl/blob/master/dabl.sablecc).
The <code>scaledmarkets.dabl.parser.Parser</code> class is
generated by the [SableCC parser generator](http://www.sablecc.org/),
based on the `dabl.sablecc` grammar.

The `LanguageAnalyzer` extends a base class that builds an Abstract Syntax Tree (AST),
as defined by the `dabl.sablecc` grammar spec. This AST construction constitutes the
Parse phase.

![Figure 2: Compiler Top Level Structure](Compiler_Design_Fig1.png "Figure 1: Compiler Top Level Structure")

## Key Dynamic Structures

The compiler's dynamic structure is completely encapsulated in the
[`CompilerState`](analysis/CompilerState.java) object.
The argument-less `process()` method creates a `CompilerState` instance and provides
it when constructing a `LanguageAnalyzer`.

The dynamic structures are shown in the following Figure. The `CompilerState`
object is returned by the compiler.

![Figure 3: Dynamic Structures](Compiler_Design_Fig2.png "Figure 2: Dynamic Structures")

## Language Analyzer

The [LanguageAnalyzer](analysis/LanguageAnalyzer.java) class performs the Analysis processing phase
(see https://github.com/Scaled-Markets/dabl/tree/master/langref#processing-phases).

The Analysis phase walks the tree in a depth-first manner, visiting each `Node`,
calling the `in`*Node-Type*(`Node`) method on entry to each Node, and the
`out`*Node-Type*(`Node`) method on exit from the `Node`. The `LanguageAnalyzer`
class provides these methods, as overrides of `in`*Node-Type*(`Node`) and
`out`*Node-Type*(`Node`) methods from the base class. These methods
perform actions such as name resolution and evaluate some static
expressions. The outcome of the Analysis phase
is a hashtable of `Annotations`, indexed by `Node`: thus, Analysis effectively annotates
the AST, since for any `Node`, one can look up its `Annotation` (if any).

The Analysis phase also produces a symbol table tree, with one table corresponding
to each nested scope within the source input.

![Figure 4: Language Analyzer Structure](Compiler_Design_Fig3.png "Figure 3: Language Analyzer Structure")

## AST Annotations

There are three kinds of annotation:

* `NameScope`.
* `SymbolEntry`.
* `IdRefAnnotation`.

Each implements the `Annotation` interface.

Note that there are two separate annotation tables: `in` and `out`. `in` annotations
are added by `in`*Node-Type*() methods, and `out` annotations are added
by `out`*Node-Type*() methods.

The structure of annotations is shown in the figure.

![Figure 5: AST Annotations](Compiler_Design_Fig4.png "Figure 4: AST Annotations")

## Symbol Table Structure

A `NameScope` is an annotation that specifies that the associated `Node` is a
declarative region (within which symbols can be defined). `NameScopes` form a
hierarchy. Each `NameScope` owns one `SymbolTable`, which contains the symbols
that are declared by that declarative region. This is depicted in the figure.

![Figure 6: Symbol Table Structure](Compiler_Design_Fig5.png "Figure 5: Symbol Table Structure")

## Compiler Output

The compiler returns a [`CompilerState`](analysis/CompilerState.java) object. In the
`CompilerState`, the `globalScope` variable references the root level
[`NameScope`](analysis/NameScope.java) object.
A `NameScope` references a [`SymbolTable`](analysis/SymbolTable.java) consisting of
[`SymbolEntries`](analysis/SymbolEntry.java).
`SymbolEntries` that are [`NameScopeEntries`](analysis/NameScopeEntry.java) own their
own `NameScopes`,
which in turn reference their own `SymbolTables`, creating a hierarchy
of `NameScopes`.

The `CompilerState` also references an abstract syntax tree (AST),
whose structure is defined by the Abstract Syntax Tree section of the
[dabl.sablecc](https://github.com/Scaled-Markets/dabl/blob/master/dabl.sablecc)
file,
and which can be accessed via the methods in the generated `scaledmarkets.dabl.node` package.
The AST node Java classes are generated by the build process; their Javadocs
can be found in package `scaledmarkets.dabl.node` of the
[generated javadocs](https://scaledmarkets.github.io/dabl/).

The linkage between the AST and the `NameScope` hierarchy is as follows:
`SymbolEntries` that are [`DeclaredEntries`](analysis/DeclaredEntry.java)
provide a `getDefiningNode()` method, which provides a reference to
the AST `Node` that declares the symbol that the `SymbolEntry` defines.

## Dependency Graph

A Dependency Graph is a non-persistent structure that is created by the Controller
in order to decide which tasks to execute in response to an external event.

The purpose of the dependency graph is to determine the order of task execution:
task A must be executed before task B if task B is “downstream” from A - that is,
if A produces outputs that eventually affect inputs to B. Also, if neither A or B
are downstream from the other, then they exist in distinct dependency graphs.
Distinct graphs can be executed in parallel.

A dependency graph can be constructed by simply removing the artifacts from the
graph of tasks and their input and output artifacts. The key algorithms are as follows.


![Figure 7: Logical Dependency Graphs](LogicalDependencyGraph.png "Figure 6: Logical Dependency Graphs")

<b>genDependencies()</b>
<ol>
<li>Create a graph of the artifact/task flow relationships.</li>
<li>Determine the task dependency graph.</li>
<li>Identify the root tasks - those not dependent on any other task.</li>
</ol>

<b>executeAll(set S of task dependency graphs)</b>
For each root task tr,
<ol>
<li>executeTaskTree(tr)</li>
</ol>

<b>executeTaskTree(Task t)</b>
<ol>
If t is not downstream from a task that has not been visited yet,
	<ol>
    <li>If t’s ‘when’ condition is true, then execute(t).</li>
    <li>For each task t_o that is immediately downstream of t,
    	<ol>
        <li>executeTaskTree(t_o)</li>
        </ol>
        </li>
</ol>

<b>genDependencies()</b>
<ol>
<li>Create a graph of the artifact/task flow relationships:
<ol>
<li>For each task,
<ol>
<li>Add a new Task to the set of tasks.</li>
<li>For each of the task’s inputs,
<ol>
<li>If the input Artifact does not exist, then create a new Artifact.</li>
<li>Add the task to the input Artifact’s list of “IsReadBy”.</li>
<li>Add the input Artifact to the task’s list of inputs.</li>
</ol>
</li>
<li>For each of the task’s outputs,
<ol>
<li>If the output Artifact does not exist, then create a new Artifact.</li>
<li>Add the task to the output Artifact’s list of “IsWrittenBy”.</li>
<li>Add the output Artifact to the task’s list of outputs.</li>
</ol>
</li>
</li>
</ol>
</li>

<li>Determine task dependency graph:
For each Artifact,
Add a Producer and Consumer relation between each input task and each output task.
</li>

<li>Identify root tasks:
For each task,
If that has no producer, then
Add it to the set of root tasks.
</li>
</ol>

![Figure 8: Actual Dependency Graphs](ActualGraph.png "Figure 7: Actual Dependency Graphs")
