// SableCC grammar for Dependent Artifact Build Language (DABL).
// For SableCC info, see http://www.sablecc.org/
// For a good SableCC reference, see http://www.natpryce.com/articles/000531.html


Package scaledmarkets.dabl;


Helpers

	any_character = [0x0 .. 0xfffff];
	tab   = 9;
	cr    = 13;
	nl    = 10;
	dollar = '$';
	blank = ' ' | nl | cr nl | tab;
	lcletter = ['a' .. 'z'];
	ucletter = ['A' .. 'Z'];
	underscore = '_';
	letter = (lcletter | ucletter | underscore);
	digit = ['0' .. '9'];
	escape = '%' digit digit;
	quote = '"';
	slashslash = '//';
	slashstar = '/*';
	slashslashstar = '//*'


Tokens

	// Punctuation:
	plus = '+';
	dash = '-';
	asterisk = '*';
	div = '/';
	gt = '>';
	lt = '<';
	ge = '>=';
	le = '<=';
	eq = '=';
	ne = '!=';
	colon = ':';
	semicolon = ';';
	per = '.';
	dotdot = '..';
	comma = ',';
	qmark = '?';
	def = 'def';
	left_paren = '(';
	right_paren = ')';
	left_cur = '{';
	right_cur = '}';
	left_brack = '[';
	right_brack = ']';
	
	// Non-keyword Sequences:
	number = digit+;
	whitespace = (blank)+;
	id = letter ( letter | digit )*;
	non_ws_char_seq = [ any_character - quote - comma]*;
	string = quote [ any_character - quote ]* quote;
	slashcomment = slashslash [ any_character - nl ]* nl;
	
	// Propositional Keywords:
	from = 'from';
	to = 'to';
	in = 'in';
	for = 'for';
	with = 'with';
	when = 'when';
	on = 'on';
	of = 'of';
	
	// Keywords:
	namespace = 'namespace';
	import = 'import';
	tab_keyword = 'tab'
	equivalent = 'equivalent';
	spaces_keyword = 'spaces';
	artifact = 'artifact';
	task = 'task';
	public = 'public';
	repo = 'repo';
	type = 'type';
	git = 'git';
	maven = 'maven';
	files = 'files';
	shell = 'shell';
	translation = 'translation';
	translate = 'translate';
	filename = 'filename';
	prefer = 'prefer';
	latest = 'latest';
	assume = 'assume';
	compatible = 'compatible';
	tested = 'tested';
	function = 'function';
	binds = 'binds';
	method = 'method';
	returns = 'returns';
	succeeded = 'succeeded';
	failed = 'failed';
	newer = 'newer';
	older = 'older';
	than = 'than';
	inputs = 'inputs';
	outputs = 'outputs';
	path = 'path';
	scheme = 'scheme';
	error = 'error';
	string = 'string';
	int = 'int';
	float = 'float';
	array = 'array';
	


Ignored Tokens

	slashcomment,
	whitespace;


Productions


  // Statement syntax.
  
	specification =
		spec_elt_seq ;
	
	spec_elt_seq =
		spec_elt spec_elt_seq
	  | spec_elt
	  ;

	spec_elt =
		namespace_decl
	  | import_decl
	  | typographic_decl
	  | artifact_decl
	  | task_decl
	  | repo_decl
	  | files_decl
	  | function_decl
	  | translation_decl
	  ;
	
	typographic_decl =
		tabl_decl;
	
	namespace_decl =
		namespace path;
	
	import_decl =
		import path;
	
	tab_decl =
		tab_keyword equivalent to number spaces_keyword;
		
	artifact_decl =
		artifact id colon expression per expression artifact_stmts;
	
	artifact_stmts =
		artifact_stmt artifact_stmts
	  | artifact_stmt
	  | ;
	
	artifact_stmt =
		assume_stmt
	  | tested_stmt
	  ;
	
	assume_stmt =
		assume compatible with id colon version_spec;
	
	tested_stmt =
		tested with id colon version_spec;
	
	scope_decl =
		public
	  | ;
	
	task_decl =
		scope_decl task id task_stmts;
	
	when_clause =
		when logical_expr;
	
	success_expr =
		id succeeded
	  | id failed
	  ;
	
	age_expr =
		id newer than id
	  | id older than id
	  ;
	
	not_expr =
		not logical_expr;
	
	logical_expr =
		not_expr
	  | success_expr
	  | age_expr
	  ;
	
	id_opt =
		id
	  | ;
	
	inputs_clause =
		inputs id_opt artifact_sets;
	
	outputs_clause =
		outputs id_opt artifact_sets;
	  
	artifact_sets =
		artifact_set artifact_sets
	  | artifact_set
	  ;
	
	// Examples:
	// files XYZ:3.3
	// abc.jar
	// $thisdir/**.java from "my_repo" in my_git
	artifact_set =
		fileset_spec from string in repository_id;
	
	task_stmts =
		task_stmt task_stmts
	  | task_stmt
	  | ;
	  
	task_stmt =
	  | inputs_clause
	  | outputs_clause
	  | when_clause
	  | procedural_stmt
	  ;
	
	procedural_stmt =
	  | func_call_stmt
	  | on_error_stmt
	  ;
	
	assignment_opt =
		id eq
	  |
	  ;
	
	func_call_stmt =
		assignment_opt args_opt;
	
	args_opt =
		arg args
	  | arg
	  | preposition
	  |
	  ;
	
	arg =
		string_value;
	
	on_error_stmt =
		on error procedural_stmts_opt;
	
	procedural_stmts_opt =
		procedural_stmt procedural_stmts_opt
	  | procedural_stmt
	  | 
	  ;
	
	repo_decl =
		repo id type repo_type repo_stmts;
	
	repo_stmts =
		repo_stmt repo_stmts
	  | repo_stmt
	  | ;
	
	repo_type =
		git
	  | maven
	  | svn
	  ;
	
	repo_stmt =
		repo_path_spec
	  | tcp_scheme_spec
	  | userid_spec password_spec
	  ;
	
	repo_path_spec =
		path string;
	
	tcp_scheme_spec =
		scheme string;
	
	userid_spec =
		string;
	
	password_spec =
		string;
	
	files_decl =
		files id from string in id files_stmts;
	
	string_value =
		non_ws_char_seq  // this can be a path that references a variable
	  | string
	  ;
	
	files_stmts =
		files_stmt files_stmts
	  | files_stmt
	  | ;
	
	files_stmt =
		prefer_stmt;
	
	prefer_stmt =
		prefer preference;
	
	preference =
		latest version_criteria
	  | version_spec;
	
	version_criteria =
		compatible with
	  | tested with
	  ;
	
	version_spec =
		range_spec per version_spec
	  | range_spec
	  ;
	
	range_spec =
		numeric_value dash numeric_value
	  | numeric_value
	  | asterisk
	  ;
	
	translation_decl =
		shell translation for string translation_stmts;
	
	translation_stmts =
		translation_stmt translation_stmts
	  | translation_stmt
	  | ;
	
	translation_stmt =
		translate filename string to string;
	
	numeric_value =
		number
	  ;
	
	function_decl =
		function id type_spec_seq binds to id method
		path returns type_spec;
	
	type_spec_seq =
		type_spec type_spec_seq
	  | type_spec
	  | id  // for defining a preposition that goes before or after a function arg
	  | preposition  // for defining a keyword that goes before or after a function arg
	  ;
	
	preposition =
		from
	  | to
	  | in
	  | for
	  | with
	  | when
	  | on
	  | of
	  ;
	
	type_spec = 
		string
	  | int
	  | float
	  | array of type_spec
	  ;
	
	path {-> id*} =
		{path} id per path                          {-> [id, path.id]}
	  | {id} id                                     {-> [id]};


Abstract Syntax Tree

	spec =
		

