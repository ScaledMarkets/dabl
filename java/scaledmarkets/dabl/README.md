# Compiler Design

## Template Processor

TBD


## Compiler Top Level Structure

The <code>scaledmarkets.dabl.parser.Parser</code> class parses input and builds an
Abstract Syntax Tree (AST). The language grammar and the AST structure are
both defined in the DABL language grammar spec,
[`dabl.sablecc`](https://github.com/Scaled-Markets/dabl/blob/master/dabl.sablecc).
The <code>scaledmarkets.dabl.parser.Parser</code> class is
generated by the [SableCC parser generator](http://www.sablecc.org/),
based on the `dabl.sablecc` grammar.

The `LanguageAnalyzer` extends a base class that builds an Abstract Syntax Tree (AST),
as defined by the `dabl.sablecc` grammar spec. This AST construction constitutes the
Parse phase.

![Figure 1: Compiler Top Level Structure](Compiler_Design_Fig1.png "Figure 1: Compiler Top Level Structure")

## Key Dynamic Structures

The compiler's dynamic structure is completely encapsulated in the
[`CompilerState`](CompilerState.java) object.
The argument-less `process()` method creates a `CompilerState` instance and provides
it when constructing a `LanguageAnalyzer`.

The dynamic structures are shown in the following Figure. The `CompilerState`
object is returned by the compiler.

![Figure 2: Dynamic Structures](Compiler_Design_Fig2.png "Figure 2: Dynamic Structures")

## Language Analyzer

The [LanguageAnalyzer](LanguageAnalyzer.java) class performs the Analysis processing phase
(see https://github.com/Scaled-Markets/dabl/tree/master/langref#processing-phases).

The Analysis phase walks the tree in a depth-first manner, visiting each `Node`,
calling the `in`*Node-Type*(`Node`) method on entry to each Node, and the
`out`*Node-Type*(`Node`) method on exit from the `Node`. The `LanguageAnalyzer`
class provides these methods, as overrides of `in`*Node-Type*(`Node`) and
`out`*Node-Type*(`Node`) methods from the base class. These methods
perform actions such as name resolution and evaluate some static
expressions. The outcome of the Analysis phase
is a hashtable of `Annotations`, indexed by `Node`: thus, Analysis effectively annotates
the AST, since for any `Node`, one can look up its `Annotation` (if any).

The Analysis phase also produces a symbol table tree, with one table corresponding
to each nested scope within the source input.

![Figure 3: Language Analyzer Structure](Compiler_Design_Fig3.png "Figure 3: Language Analyzer Structure")

## AST Annotations

There are three kinds of annotation:

* `NameScope`.
* `SymbolEntry`.
* `IdRefAnnotation`.

Each implements the `Annotation` interface.

Note that there are two separate annotation tables: `in` and `out`. `in` annotations
are added by `in`*Node-Type*() methods, and `out` annotations are added
by `out`*Node-Type*() methods.

The structure of annotations is shown in the figure.

![Figure 4: AST Annotations](Compiler_Design_Fig4.png "Figure 4: AST Annotations")

## Symbol Table Structure

A `NameScope` is an annotation that specifies that the associated `Node` is a
declarative region (within which symbols can be defined). `NameScopes` form a
hierarchy. Each `NameScope` owns one `SymbolTable`, which contains the symbols
that are declared by that declarative region. This is depicted in the figure.

![Figure 5: Symbol Table Structure](Compiler_Design_Fig5.png "Figure 5: Symbol Table Structure")

## Compiler Output

The compiler returns a [`CompilerState`](analysis/CompilerState.java) object. In the
`CompilerState`, the `globalScope` variable references the root level
[`NameScope`](analysis/NameScope.java) object.
A `NameScope` references a [`SymbolTable`](analysis/SymbolTable.java) consisting of
[`SymbolEntries`](analysis/SymbolEntry.java).
`SymbolEntries` that are [`NameScopeEntries`](analysis/NameScopeEntry.java) own their
own `NameScopes`,
which in turn reference their own `SymbolTables`, creating a hierarchy
of `NameScopes`.

The `CompilerState` also references an abstract syntax tree (AST),
whose structure is defined by the Abstract Syntax Tree section of the
[dabl.sablecc](https://github.com/Scaled-Markets/dabl/blob/master/dabl.sablecc)
file,
and which can be accessed via the methods in the generated `scaledmarkets.dabl.node` package.
The AST node Java classes are generated by the build process; their Javadocs
can be found in package `scaledmarkets.dabl.node` of the
[generated javadocs](https://scaledmarkets.github.io/dabl/).

The linkage between the AST and the `NameScope` hierarchy is as follows:
`SymbolEntries` that are [`DeclaredEntries`](analysis/DeclaredEntry.java)
provide a `getDefiningNode()` method, which provides a reference to
the AST `Node` that declares the symbol that the `SymbolEntry` defines.
