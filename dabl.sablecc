// SableCC grammar for Dependent Artifact Build Language (DABL).
// For SableCC info, see http://www.sablecc.org/
// For a good SableCC reference, see http://www.natpryce.com/articles/000531.html


Package scaledmarkets.dabl;


Helpers

	any_character = [0x0 .. 0xfffff];
	tab   = 9;
	cr    = 13;
	nl    = 10;
	dollar = '$';
	comma = ',';
	blank = ' ';
	lcletter = ['a' .. 'z'];
	ucletter = ['A' .. 'Z'];
	underscore = '_';
	letter = (lcletter | ucletter | underscore);
	digit = ['0' .. '9'];
	escape = '%' digit digit;
	quote = '"';
	slashslash = '//';
	slashslashslash = '///';
	slashstar = '/*';
	starslash = '*/';
	slashslashstar = '//*';
	starslashslash = '*//';
	linetermination = (cr nl | nl);


Tokens

	// Punctuation:
	tab_char = tab;
	nl_char = nl;
	comma_char = comma;
	plus = '+';
	dash = '-';
	asterisk = '*';
	div = '/';
	gt = '>';
	lt = '<';
	ge = '>=';
	le = '<=';
	eq = '=';
	ne = '!=';
	colon = ':';
	semicolon = ';';
	per = '.';
	dotdot = '..';
	qmark = '?';
	def = 'def';
	left_paren = '(';
	right_paren = ')';
	left_cur = '{';
	right_cur = '}';
	left_brack = '[';
	right_brack = ']';
	
	// Non-keyword Sequences:
	number = digit+;
	whitespace = (blank)+;
	id = letter ( letter | digit )*;
	non_ws_char_seq = [ any_character - [ quote + comma ] ]*;
	string = quote [ any_character - quote ]* quote;
	slashslashcomment = slashslash [ any_character - nl ]* nl;
	slashslashslashcomment = slashslashslash [ any_character - nl ]* nl;
	slashstarcomment = slashstar any_character* starslash;
	slashslashstarcomment = slashslashstar any_character* starslashslash;
	
	// Propositional Keywords:
	from = 'from';
	to = 'to';
	in = 'in';
	for = 'for';
	with = 'with';
	when = 'when';
	on = 'on';
	of = 'of';
	than = 'than';
	
	// Keywords:
	namespace = 'namespace';
	import = 'import';
	tab_keyword = 'tab';
	equivalent = 'equivalent';
	spaces_keyword = 'spaces';
	artifact = 'artifact';
	task = 'task';
	public = 'public';
	repo = 'repo';
	type = 'type';
	git = 'git';
	maven = 'maven';
	svn = 'svn';
	files = 'files';
	shell = 'shell';
	translation = 'translation';
	translate = 'translate';
	filename = 'filename';
	prefer = 'prefer';
	latest = 'latest';
	assume = 'assume';
	compatible = 'compatible';
	tested = 'tested';
	function = 'function';
	binds = 'binds';
	method = 'method';
	returns = 'returns';
	succeeded = 'succeeded';
	failed = 'failed';
	newer = 'newer';
	older = 'older';
	inputs = 'inputs';
	outputs = 'outputs';
	path_keyword = 'path';
	scheme = 'scheme';
	error = 'error';
	string_keyword = 'string';
	int_keyword = 'int_keyword';
	float_keyword = 'float_keyword';
	array_keyword = 'array_keyword';
	not_keyword = 'not';
	include = 'include';
	exclude = 'exclude';


Ignored Tokens

	slashslashcomment,
	slashslashslashcomment,
	slashstarcomment,
	slashslashstarcomment,
	whitespace;


Productions

	specification { -> onamespace } =
		spec_elt_seq;
	
	spec_elt_seq =
		{multiple} spec_elt spec_elt_seq
	  | {one} spec_elt
	  ;
	 
	spec_elt =
		{namespace_decl} namespace_decl
	  | {import_decl} import_decl
	  | {typographic_decl} typographic_decl
	  | {artifact_decl} artifact_decl
	  | {task_decl} task_decl
	  | {repo_decl} repo_decl
	  | {files_decl} files_decl
	  | {function_decl} function_decl
	  | {translation_decl} translation_decl
	  ;
	
	typographic_decl =
		tab_decl;
	
	namespace_decl =
		namespace path;
	
	import_decl =
		import path;
	
	tab_decl =
		tab_keyword equivalent to number spaces_keyword;
		
	artifact_decl =
		artifact id colon [expr1]:whole_number_expr per [expr2]:whole_number_expr artifact_stmts;
	
	whole_number_expr =
		number;
	
	artifact_stmts =
		{multiple} artifact_stmt artifact_stmts
	  | {one} artifact_stmt
	  | {none} ;
	
	artifact_stmt =
		{assume_stmt} assume_stmt
	  | {tested_stmt} tested_stmt
	  ;
	
	assume_stmt =
		assume compatible with id colon version_spec;
	
	tested_stmt =
		tested with id colon version_spec;
	
	scope_decl =
		{public} public
	  | {unspecified}
	  ;
	
	task_decl =
		scope_decl task id task_stmts;
	
	when_clause =
		when logical_expr;
	
	success_expr =
		{succeeded} id succeeded
	  | {failed} id failed
	  ;
	
	age_expr =
		{newer_than} [newer_id]:id newer than [older_id]:id
	  | {older_than} [older_id]:id older than [newer_id]:id
	  ;
	
	not_expr =
		not_keyword logical_expr;
	
	logical_expr =
		{not} not_expr
	  | {success} success_expr
	  | {age} age_expr
	  ;
	
	id_opt =
		{id} id
	  | {nothing} ;
	
	string_value =
		{non_ws} non_ws_char_seq  // this can be a path that references a variable
	  | {str} string
	  ;
	
	inputs_clause =
		inputs id_opt artifact_sets;
	
	outputs_clause =
		outputs id_opt artifact_sets;
	  
	artifact_sets =
		{multiple} artifact_set comma_char artifact_sets
	  | {one} artifact_set
	  ;
	
	// Examples:
	// files XYZ:3.3
	// abc.jar
	// $thisdir/**.java from "my_repo" in my_git
	artifact_set =
		fileset_spec from [project]:string in [repository_id]:id;
	
	fileset_spec =
		string_value;
	
	files_decl =
		files [name]:id from string in [source]:id files_stmts;
	
	files_stmts =
		{multiple} files_stmt files_stmts
	  | {one} files_stmt
	  | {none}
	  ;
	
	files_stmt =
		{prefer} prefer_stmt
	  | {include} include_stmt
	  | {exclude} exclude_stmt
	  ;
	
	prefer_stmt =
		prefer preference;
	
	preference =
		{latest} latest version_criteria
	  | {version} version_spec
	  ;
	
	version_criteria =
		{compatible} compatible with
	  | {tested} tested with
	  ;
	
	version_spec =
		{multiple} range_spec per version_spec
	  | {one} range_spec
	  ;
	
	range_spec =
		{multiple} [from]:numeric_value dash [to]:numeric_value
	  | {one} numeric_value
	  | {all} asterisk
	  ;
	
	include_stmt =
		include fileset_spec;
	
	exclude_stmt =
		exclude fileset_spec;
	
	task_stmts =
		{multiple} task_stmt task_stmts
	  | {one} task_stmt
	  | {none}
	  ;
	  
	task_stmt =
	  | {inputs} inputs_clause
	  | {outputs} outputs_clause
	  | {when} when_clause
	  | {procedural} procedural_stmt
	  ;
	
	procedural_stmt =
	  | {func_call} func_call_stmt
	  | {on_error} on_error_stmt
	  ;
	
	assignment_opt =
		{id} id eq
	  | {nothing} 
	  ;
	
	func_call_stmt =
		assignment_opt args_opt;
	
	args_opt =
		{multiple_args} arg args_opt
	  | {one_arg} arg
	  | {preoposition} preposition
	  | {nothing} 
	  ;
	
	arg =
		string_value;
	
	on_error_stmt =
		on error procedural_stmts_opt;
	
	procedural_stmts_opt =
		{multiple} procedural_stmt procedural_stmts_opt
	  | {one} procedural_stmt
	  | {none} 
	  ;
	
	repo_decl =
		repo id type repo_type repo_stmts;
	
	repo_stmts =
		{multiple} repo_stmt repo_stmts
	  | {one} repo_stmt
	  | {none}
	  ;
	
	repo_type =
		{git} git
	  | {maven} maven
	  | {svn} svn
	  ;
	
	repo_stmt =
		{repo_path} repo_path_spec
	  | {tcp_scheme} tcp_scheme_spec
	  | {userid} userid_spec password_spec
	  ;
	
	repo_path_spec =
		path_keyword string;
	
	tcp_scheme_spec =
		scheme string;
	
	userid_spec =
		string;
	
	password_spec =
		string;
	
	translation_decl =
		shell translation for string translation_stmts;
	
	translation_stmts =
		{multiple} translation_stmt translation_stmts
	  | {one} translation_stmt
	  | {none}
	  ;
	
	translation_stmt =
		translate filename [from_string]:string to [to_string]:string;
	
	numeric_value =
		number
	  ;
	
	function_decl =
		function [dable_name]:id type_spec_seq binds to [target_name]:id method
			path returns type_spec;
	
	type_spec_seq =
		{multiple} type_spec type_spec_seq
	  | {one} type_spec
	  | {id} id  // for defining a preposition that goes before or after a function arg
	  | {preposition} preposition  // for defining a keyword that goes before or after a function arg
	  ;
	
	preposition =
		{from} from
	  | {to} to
	  | {in} in
	  | {for} for
	  | {with} with
	  | {when} when
	  | {on} on
	  | {of} of
	  | {than} than
	  ;
	
	type_spec = 
		{string} string_keyword
	  | {int} int_keyword
	  | {float} float_keyword
	  | {array} array_keyword of type_spec
	  ;
	
	path =
		{multiple} id per path
	  | {one} id;


Abstract Syntax Tree

	onamespace =
		{namespace_elements} onamespace_elt*;
	
	onamespace_elt =
		{import} onamespace_path
	  | {typographic} otypographic_declaration
	  | {artifact} oartifact_declaration
	  | {repo} orepo_declaration
	  | {file} ofiles_declaration
	  | {function} ofunction_declaration
	  | {task} otask_declaration
	  | {translation} otranslation_declaration
	  ;

	otypographic_declaration =
		{tab_decl} number;

	oartifact_declaration =
		{assume} id orange_spec*
	  | {tested} id orange_spec*
		;
	
	orange_spec =
		{range} [from]:number [to]:number
	  | {one} number
	  | {all}
		;

	orepo_declaration =
		[name]:id [type]:id [userid]:non_ws_char_seq [password]:non_ws_char_seq;

	ofiles_declaration =
		ofile_preference ofileset_operation*;

	ofile_preference =
		{latest_compatible}
	  | {latest_tested}
	  | {version} orange_spec*
	  ;
	
	ofileset_operation =
		{include} string
	  | {exclude} string
	  ;
	
	ofunction_declaration =
		[name]:id otype_spec* otarget_language [target_name]:string [return_type]:otype_spec;

	otype_spec = 
		{string}
	  | {int}
	  | {float}
	  | {array} otype_spec
	  ;
	
	otarget_language =
		{groovy}
	  | {java}
	  | {scala}
	  | {clojure}
	  ;
	
	otask_declaration =
		oscope [name]:id owhen* oinput* ooutput* oproc_stmt*;
	
	oscope =
		{public}
	  | {private}
	  ;
	
	owhen =
		ological_expr;
	
	oinput =
		oartifact_set*;
	
	ooutput =
		oartifact_set*;

	oartifact_set =
		[fileset_spec]:string [project]:string [repository_id]:id;
	
	oproc_stmt =
		{func_call}
	  | {on_error}
	  ;
	
	otranslation_declaration =
		[os]:string otranslation_stmt*;
	
	otranslation_stmt =
		{filename} [from_string]:string [to_string]:string;
	
	onamespace_path =
		{import} id*;
	
	osuccess_expr =
		{succeeded} id
	  | {failed} id
	  ;
	
	oage_expr =
		{newer_than} [newer_id]:id [older_id]:id
	  | {older_than} [older_id]:id [newer_id]:id
	  ;
	
	onot_expr =
		ological_expr;
	
	ological_expr =
		{not} onot_expr
	  | {success} osuccess_expr
	  | {age} oage_expr
	  ;
	
