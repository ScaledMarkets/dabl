// SableCC grammar for Dependent Artifact Build Language (DABL).
// For SableCC info, see http://www.sablecc.org/
// For a good SableCC reference, see http://www.natpryce.com/articles/000531.html


Package scaledmarkets.dabl;


Helpers

	any_character = [0x0 .. 0xfffff];
	tab   = 9;
	cr    = 13;
	nl    = 10;
	dollar = '$';
	comma = ',';
	blank = ' ';
	lcletter = ['a' .. 'z'];
	ucletter = ['A' .. 'Z'];
	underscore = '_';
	letter = (lcletter | ucletter | underscore);
	digit = ['0' .. '9'];
	escape = '%' digit digit;
	quote = '"';
	triplequote = '"""';
	slashslash = '//';
	slashslashslash = '///';
	slashstar = '/*';
	starslash = '*/';
	slashslashstar = '//*';
	starslashslash = '*//';
	linetermination = (cr nl | nl);


Tokens

	// Punctuation:
	tab_char = tab;
	nl_char = nl;
	comma_char = comma;
	plus = '+';
	dash = '-';
	asterisk = '*';
	div = '/';
	gt = '>';
	lt = '<';
	ge = '>=';
	le = '<=';
	eq = '=';
	ne = '!=';
	colon = ':';
	semicolon = ';';
	per = '.';
	dotdot = '..';
	qmark = '?';
	def = 'def';
	left_paren = '(';
	right_paren = ')';
	left_cur = '{';
	right_cur = '}';
	left_brack = '[';
	right_brack = ']';
	
	// Variable Length Sequences:
	number = digit+;
	whitespace = (blank)+;
	id = letter ( letter | digit )*;
	non_ws_char_seq = [ any_character - [ quote + comma ] ]*;
	string = quote [ any_character - quote ]* quote;
	string2 = triplequote [ any_character - triplequote ]* triplequote;
	slashslashcomment = slashslash [ any_character - nl ]* nl;
	slashslashslashcomment = slashslashslash [ any_character - nl ]* nl;
	slashstarcomment = slashstar any_character* starslash;
	slashslashstarcomment = slashslashstar any_character* starslashslash;
	
	// Propositional Keywords:
	from = 'from';
	to = 'to';
	in = 'in';
	for = 'for';
	with = 'with';
	when = 'when';
	on = 'on';
	of = 'of';
	than = 'than';
	
	// Non-Propositional Keywords:
	namespace = 'namespace';
	import = 'import';
	tab_keyword = 'tab';
	equivalent = 'equivalent';
	spaces_keyword = 'spaces';
	artifact = 'artifact';
	task = 'task';
	public = 'public';
	repo = 'repo';
	type = 'type';
	git = 'git';
	maven = 'maven';
	svn = 'svn';
	files = 'files';
	shell = 'shell';
	translation = 'translation';
	translate = 'translate';
	filename = 'filename';
	prefer = 'prefer';
	latest = 'latest';
	assume = 'assume';
	compatible = 'compatible';
	tested = 'tested';
	function = 'function';
	binds = 'binds';
	method = 'method';
	returns = 'returns';
	succeeded = 'succeeded';
	failed = 'failed';
	newer = 'newer';
	older = 'older';
	inputs = 'inputs';
	outputs = 'outputs';
	path_keyword = 'path';
	scheme = 'scheme';
	error = 'error';
	string_keyword = 'string';
	int_keyword = 'int_keyword';
	float_keyword = 'float_keyword';
	array_keyword = 'array_keyword';
	not_keyword = 'not';
	include = 'include';
	exclude = 'exclude';


Ignored Tokens

	slashslashcomment,
	slashslashslashcomment,
	slashstarcomment,
	slashslashstarcomment,
	whitespace;


// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
Productions

	specification {-> onamespace} =
		{namespace_decl} namespace_decl spec_elt_seq	{-> New onamespace.namespace_elts(
															[namespace_decl.id],
															[spec_elt_seq.onamespace_elt])};
	
	namespace_decl {-> id*} =
		namespace path									{-> [path.id]};
	
	spec_elt_seq {-> onamespace_elt*} =
		{multiple} spec_elt spec_elt_seq				{-> [spec_elt.onamespace_elt, spec_elt_seq.onamespace_elt]}
	  | {one} spec_elt									{-> [spec_elt.onamespace_elt]}
	  ;
	 
	spec_elt {-> onamespace_elt} =
		{import_decl} import_decl						{-> import_decl.onamespace_elt}
	  | {typographic_decl} typographic_decl				{-> New onamespace_elt.typographic(typographic_decl.otypographic_declaration)}
	  | {artifact_decl} artifact_decl					{-> }
	  | {task_decl} task_decl							{-> }
	  | {repo_decl} repo_decl							{-> }
	  | {files_decl} files_decl							{-> }
	  | {function_decl} function_decl					{-> }
	  | {translation_decl} translation_decl				{-> }
	  ;
	
	typographic_decl {-> otypographic_declaration} =
		tab_decl					{-> tab_decl.otypographic_declaration}
		;
	
	import_decl {-> onamespace_elt} =
		import path					{-> New onamespace_elt.import([path.id])}
		;
	
	tab_decl {-> otypographic_declaration} =
		tab_keyword equivalent to number spaces_keyword	{-> New otypographic_declaration.tab_decl(number)}
		;
		
	artifact_decl {-> oartifact_declaration} =
		artifact id colon [expr1]:whole_number_expr
			per [expr2]:whole_number_expr
			artifact_stmts			{-> New oartifact_declaration(id, expr1.number,
										expr2.number, [artifact_stmts.ocompatibility_spec]}
		;
	
	whole_number_expr {-> number} =
		number						{-> number}
		;
	
	artifact_stmts {-> ocompatibility_spec*} =
		{multiple} artifact_stmt artifact_stmts	{-> [artifact_stmt.ocompatibility_spec,
													artifact_stmts.ocompatibility_spec]}
	  | {one} artifact_stmt			{-> [artifact_stmt.ocompatibility_spec]}
	  | {none}						{-> []}
	  ;
	
	artifact_stmt {-> ocompatibility_spec} =
		{assume_stmt} assume_stmt	{-> assume_stmt.ocompatibility_spec}
	  | {tested_stmt} tested_stmt	{-> assume_stmt.ocompatibility_spec}
	  ;
	
	assume_stmt {-> ocompatibility_spec} =
		assume compatible with path colon version_spec	{-> New ocompatibility_spec.assume(
										[path.id], version_spec.orange_spec)}
		;
	
	tested_stmt {-> ocompatibility_spec} =
		tested with path colon version_spec	{-> New ocompatibility_spec.tested(
										[path.id], version_spec.orange_spec)}
		;
	
	scope_decl {-> oscope} =
		{public} public				{-> New oscope.public()}
	  | {unspecified}				{-> New oscope.private()}
	  ;
	
	task_decl {-> otask_declaration} =
		scope_decl task id when_clause input_sets output_sets
			procedural_stmts		{-> New otask_declaration(scope_decl.oscope,
										id, when_clause.ological_expr,
										[input_sets.onamed_artifact_set],
										[output_sets.onamed_artifact_set],
										[procedural_stmts.oproc_stmt])}
		;
	
	when_clause {-> ological_expr*} =
		when logical_expr			{-> logocal_expr.ological_expr}
		;
	
	success_expr {-> osuccess_expr} =
		{succeeded} id succeeded	{-> New osuccess_expr.succeeded(id)}
	  | {failed} id failed			{-> New osuccess_expr.failed(id)}
	  ;
	
	age_expr {-> oage_expr} =
		{newer_than} [newer_id]:id newer than [older_id]:id
									{-> New oage_expr.newer_than(newer_id, older_id)}
	  | {older_than} [older_id]:id older than [newer_id]:id
	  								{-> New oage_expr.older_than(older_id, newer_id)}
	  ;
	
	string_value {-> ostring_value} =
		{non_ws} non_ws_char_seq  // this can be a path that references a variable
									{-> New ostring_value.charseq(non_ws_char_seq)}
	  | {str} string				{-> New ostring_value.string(string)}
	  | {str2} string2				{-> New ostring_value.string2(string2)}
	  ;
	
	input_sets {-> onamed_artifact_set*} =
		{multiple} input_set input_sets		{-> [input_set.onamed_artifact_set,
												input_sets.onamed_artifact_set]}
	  | {one} input_set				{-> [input_set.onamed_artifact_set]}
	  | {none}						{-> []}
	  ;
	
	input_set {-> onamed_artifact_set} =
		{named} inputs id artifact_sets		{-> New onamed_artifact_set.named(id,
												[artifact_sets.oartifact_set]}
	  | {anonymous} inputs artifact_sets	{-> New onamed_artifact_set.anonymous(
												[artifact_sets.oartifact_set]}
		;
	
	output_sets {-> onamed_artifact_set*} =
		{multiple} output_set output_sets		{-> [output_set.onamed_artifact_set,
												output_sets.onamed_artifact_set]}
	  | {one} output_set				{-> [output_set.onamed_artifact_set]}
	  | {none}							{-> []}
	  ;
	
	output_set {-> onamed_artifact_set} =
		{named} outputs id artifact_sets	{-> New onamed_artifact_set.named(id,
												[artifact_sets.oartifact_set]}
		{anonymous} outputs artifact_sets	{-> New onamed_artifact_set.anonymous(
												[artifact_sets.oartifact_set]}
		;
	  
	artifact_sets {-> oartifact_set*} =
		{multiple} artifact_set comma_char artifact_sets
											{-> [artifact_set.oartifact_set, artifact_sets.oartifact_set]}
	  | {one} artifact_set					{-> [artifact_set.oartifact_set]}
	  ;
	
	// Examples:
	// files XYZ:3.3
	// abc.jar
	// $thisdir/**.java from "my_repo" in my_git
	artifact_set {-> oartifact_set} =
		fileset_spec from [project]:string_value
		in [repository_id]:id				{-> New oartifact_set(fileset_spec.ostring_value,
												New ostring_value(string_value), id)}
		;
	
	fileset_spec {-> ostring_value} =
		string_value						{-> New ostring_value(string_value)}
		;
	
	files_decl {-> ofiles_declaration} =
		files [name]:id from string_value
			in [source]:id prefer_stmt_opt
			files_stmts						{-> New ofiles_declaration(
												prefer_stmt_opt.ofile_preference,
												[files_stmts.ofileset_operation]}
		;
	
	files_stmts {-> ofileset_operation*} =
		{multiple} files_stmt files_stmts	{-> [files_stmt.ofileset_operation,
												files_stmts.ofileset_operation]}
	  | {one} files_stmt					{-> [files_stmt.ofileset_operation]}
	  | {none}								{-> []}
	  ;
	
	files_stmt {-> ofileset_operation} =
	  | {include} include_stmt				{-> include_stmt.ofileset_operation}
	  											
	  | {exclude} exclude_stmt				{-> exclude_stmt.ofileset_operation}
	  ;
	
	prefer_stmt {-> ofile_preference} =
		prefer preference					{-> preference.ofile_preference}
		;
	
	prefer_stmt_opt {-> ofile_preference} =
		prefer_stmt							{-> prefer_stmt.ofile_preference}
	  | 									{-> }
	  ;
	
	preference {-> ofile_preference} =
		{latest} latest version_criteria	{-> version_criteria.ofile_preference}
	  | {version} version_spec				{-> New ofile_preference.version([version_spec.orange_spec])}
	  ;
	
	version_criteria {-> ofile_preference} =
		{compatible} compatible with		{-> New ofile_preference.latest_compatible}
	  | {tested} tested with				{-> New ofile_preference.latest_tested}
	  ;
	
	version_spec {-> orange_spec*} =
		{multiple} range_spec per version_spec	{-> [range_spec.orange_spec, version_spec.orange_spec]}
	  | {one} range_spec					{-> [range_spec.orange_spec]}
	  ;
	
	range_spec {-> orange_spec} =
		{multiple} [from]:numeric_value dash [to]:numeric_value
	  | {one} numeric_value
	  | {all} asterisk
	  ;
	
	include_stmt {-> ofileset_operation} =
		include fileset_spec	{-> New ofileset_operation.include(fileset_spec.ostring_value)}
		;
	
	exclude_stmt {-> ofileset_operation} =
		exclude fileset_spec	{-> New ofileset_operation.exclude(fileset_spec.ostring_value)}
		;
	
	procedural_stmts {-> oproc_stmt*} =
		{multiple} procedural_stmt procedural_stmts
	  | {one} procedural_stmt
	  | {none}
	  ;
	  
	procedural_stmt =
	  | {func_call} func_call_stmt
	  | {on_error} on_error_stmt
	  ;
	
	assignment_opt =
		{id} id eq
	  | {nothing} 
	  ;
	
	func_call_stmt =
		assignment_opt args_opt;
	
	args_opt =
		{multiple_args} arg args_opt
	  | {one_arg} arg
	  | {preoposition} preposition
	  | {nothing} 
	  ;
	
	arg =
		string_value;
	
	on_error_stmt =
		on error procedural_stmts_opt;
	
	procedural_stmts_opt =
		{multiple} procedural_stmt procedural_stmts_opt
	  | {one} procedural_stmt
	  | {none} 
	  ;
	
	repo_decl =
		repo id type repo_type repo_stmts;
	
	repo_stmts =
		{multiple} repo_stmt repo_stmts
	  | {one} repo_stmt
	  | {none}
	  ;
	
	repo_type =
		{git} git
	  | {maven} maven
	  | {svn} svn
	  ;
	
	repo_stmt =
		{repo_path} repo_path_spec
	  | {tcp_scheme} tcp_scheme_spec
	  | {userid} userid_spec password_spec
	  ;
	
	repo_path_spec =
		path_keyword string_value;
	
	tcp_scheme_spec =
		scheme string_value;
	
	userid_spec =
		string_value;
	
	password_spec =
		string_value;
	
	translation_decl =
		shell translation for string_value translation_stmts;
	
	translation_stmts =
		{multiple} translation_stmt translation_stmts
	  | {one} translation_stmt
	  | {none}
	  ;
	
	translation_stmt =
		translate filename [from_string]:string_value to [to_string]:string_value;
	
	numeric_value =
		number
	  ;
	
	function_decl =
		function [dable_name]:id type_spec_seq binds to [target_name]:id method
			path returns type_spec;
	
	type_spec_seq =
		{multiple} type_spec type_spec_seq
	  | {one} type_spec
	  | {id} id  // for defining a preposition that goes before or after a function arg
	  | {preposition} preposition  // for defining a keyword that goes before or after a function arg
	  ;
	
	preposition =
		{from} from
	  | {to} to
	  | {in} in
	  | {for} for
	  | {with} with
	  | {when} when
	  | {on} on
	  | {of} of
	  | {than} than
	  ;
	
	type_spec = 
		{string} string_keyword
	  | {int} int_keyword
	  | {float} float_keyword
	  | {array} array_keyword of type_spec
	  ;
	
	path {-> id*} =
		{multiple} id per path
	  | {one} id;

	
	// Logical expressions.
	
	logical_expr {-> ological_expr} =
		{not} not_expr
	  | {success} success_expr
	  | {age} age_expr
	  | {paren} parenthetic_logical_expr
	  ;
	
	not_expr =
		not_keyword logical_expr;
	
	parenthetic_logical_expr =
		left_paren logical_expr right_paren
		;
	

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
Abstract Syntax Tree

	onamespace =
		{namespace_elts} [path]:id* onamespace_elt*;
	
	onamespace_elt =
		{import} id*
	  | {typographic} otypographic_declaration
	  | {artifact} oartifact_declaration
	  | {repo} orepo_declaration
	  | {file} ofiles_declaration
	  | {function} ofunction_declaration
	  | {task} otask_declaration
	  | {translation} otranslation_declaration
	  ;

	otypographic_declaration =
		{tab_decl} number;

	oartifact_declaration =
		id [major]:number [minor]:number ocompatibility_spec*
		;
	
	orange_spec =
		{range} [from]:number [to]:number
	  | {one} number
	  | {all}
		;
	
	ocompatibility_spec =
		{assume} id* orange_spec
	  | {tested} id* orange_spec
		;

	orepo_declaration =
		[name]:id [type]:id [userid]:non_ws_char_seq [password]:non_ws_char_seq;

	ofiles_declaration =
		ofile_preference ofileset_operation*;

	ofile_preference =
		{latest_compatible}
	  | {latest_tested}
	  | {version} orange_spec*
	  ;
	
	ofileset_operation =
		{include} ostring_value
	  | {exclude} ostring_value
	  ;
	
	ofunction_declaration =
		[name]:id otype_spec* otarget_language [target_name]:ostring_value [return_type]:otype_spec;

	otype_spec = 
		{string}
	  | {int}
	  | {float}
	  | {array} otype_spec
	  ;
	
	otarget_language =
		{groovy}
	  | {java}
	  | {scala}
	  | {clojure}
	  ;
	
	otask_declaration =
		oscope [name]:id [when]:ological_expr* [input]:onamed_artifact_set*
			[output]:onamed_artifact_set* oproc_stmt*;
	
	oscope =
		{public}
	  | {private}
	  ;
	
	onamed_artifact_set =
		{named} id oartifact_set*
	  | {anonymous} oartifact_set*
	  ;
	
	oartifact_set =
		[fileset_spec]:ostring_value [project]:ostring_value [repository_id]:id;
	
	oproc_stmt =
		{func_call}
	  | {on_error}
	  ;
	
	otranslation_declaration =
		[os]:ostring_value otranslation_stmt*;
	
	otranslation_stmt =
		{filename} [from_string]:ostring_value [to_string]:ostring_value;
	
	osuccess_expr =
		{succeeded} id
	  | {failed} id
	  ;
	
	oage_expr =
		{newer_than} [newer_id]:id [older_id]:id
	  | {older_than} [older_id]:id [newer_id]:id
	  ;
	
	onot_expr =
		ological_expr;
	
	ological_expr =
		{not} onot_expr
	  | {success} osuccess_expr
	  | {age} oage_expr
	  ;
	
	ostring_value =
		{charseq} non_ws_char_seq
		{string} string
		{string2} string2
