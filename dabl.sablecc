// SableCC grammar for Dependent Artifact Build Language (DABL).
// For SableCC info, see http://www.sablecc.org/
// For a good SableCC reference, see http://www.natpryce.com/articles/000531.html


Package scaledmarkets.dabl;


Helpers

	any_character = [0x0 .. 0xfffff];
	tab   = 9;
	cr    = 13;
	nl    = 10;
	dollar = '$';
	comma = ',';
	blank = ' ';
	lcletter = ['a' .. 'z'];
	ucletter = ['A' .. 'Z'];
	underscore = '_';
	letter = (lcletter | ucletter | underscore);
	digit = ['0' .. '9'];
	escape = '%' digit digit;
	quote = '"';
	triplequote = '"""';
	slashslash = '//';
	slashslashslash = '///';
	slashstar = '/*';
	starslash = '*/';
	slashslashstar = '//*';
	starslashslash = '*//';
	linetermination = (cr nl | nl);
	per = '.';


Tokens

	// Punctuation:
	tab_char = tab;
	nl_char = nl;
	comma_char = comma;
	plus = '+';
	dash = '-';
	asterisk = '*';
	div = '/';
	gt = '>';
	lt = '<';
	ge = '>=';
	le = '<=';
	eq = '=';
	ne = '!=';
	colon = ':';
	semicolon = ';';
	dotdot = '..';
	qmark = '?';
	def = 'def';
	left_paren = '(';
	right_paren = ')';
	left_cur = '{';
	right_cur = '}';
	left_brack = '[';
	right_brack = ']';
	per_char = per;
	
	// Variable Length Sequences:
	number = digit+;
	float_number = digit* per digit+;
	whitespace = (blank)+;
	id = letter ( letter | digit )*;
	non_ws_char_seq = [ any_character - [ quote + comma ] ]*;
	string = quote [ any_character - quote ]* quote;
	string2 = triplequote [ any_character - triplequote ]* triplequote;
	slashslashcomment = slashslash [ any_character - nl ]* nl;
	slashslashslashcomment = slashslashslash [ any_character - nl ]* nl;
	slashstarcomment = slashstar any_character* starslash;
	slashslashstarcomment = slashslashstar any_character* starslashslash;
	
	// Propositional Keywords:
	from = 'from';
	to = 'to';
	in = 'in';
	for = 'for';
	with = 'with';
	when = 'when';
	on = 'on';
	of = 'of';
	than = 'than';
	
	// Non-Propositional Keywords:
	namespace = 'namespace';
	import = 'import';
	tab_keyword = 'tab';
	equivalent = 'equivalent';
	spaces_keyword = 'spaces';
	artifact = 'artifact';
	task = 'task';
	public = 'public';
	repo = 'repo';
	type = 'type';
	git = 'git';
	maven = 'maven';
	svn = 'svn';
	files = 'files';
	shell = 'shell';
	translation = 'translation';
	translate = 'translate';
	filename = 'filename';
	prefer = 'prefer';
	latest = 'latest';
	assume = 'assume';
	compatible = 'compatible';
	tested = 'tested';
	function = 'function';
	binds = 'binds';
	method = 'method';
	returns = 'returns';
	succeeded = 'succeeded';
	failed = 'failed';
	newer = 'newer';
	older = 'older';
	inputs = 'inputs';
	outputs = 'outputs';
	path_keyword = 'path';
	scheme = 'scheme';
	error = 'error';
	string_keyword = 'string';
	int_keyword = 'int';
	float_keyword = 'float';
	boolean_keyword = 'boolean';
	not_keyword = 'not';
	and_keyword = 'and';
	or_keyword = 'or';
	include = 'include';
	exclude = 'exclude';
	true_keyword = 'true';
	false_keyword = 'false';
	userid = 'userid';
	password = 'password';


Ignored Tokens

	slashslashcomment,
	slashslashslashcomment,
	slashstarcomment,
	slashslashstarcomment,
	whitespace;


// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
Productions

	specification {-> onamespace} =
		{namespace_decl} namespace_decl spec_elt_seq
											{-> New onamespace.namespace_elts(
													[namespace_decl.id],
													[spec_elt_seq.onamespace_elt])};
	
	namespace_decl {-> id*} =
		namespace path						{-> [path.id]};
	
	spec_elt_seq {-> onamespace_elt*} =
		{multiple} spec_elt spec_elt_seq	{-> [spec_elt.onamespace_elt, spec_elt_seq.onamespace_elt]}
	  | {one} spec_elt						{-> [spec_elt.onamespace_elt]}
	  ;
	 
	spec_elt {-> onamespace_elt} =
		{import_decl} import_decl			{-> import_decl.onamespace_elt}
	  | {typographic_decl} typographic_decl	{-> New onamespace_elt.typographic(typographic_decl.otypographic_declaration)}
	  | {artifact_decl} artifact_decl		{-> New onamespace_elt.artifact(artifact_decl.oartifact_declaration)}
	  | {task_decl} task_decl				{-> New onamespace_elt.task(task_decl.otask_declaration)}
	  | {repo_decl} repo_decl				{-> New onamespace_elt.repo(repo_decl.orepo_decl)}
	  | {files_decl} files_decl				{-> New onamespace_elt.files(files_decl.ofiles_declaration)}
	  | {function_decl} function_decl		{-> New onamespace_elt.function(function_decl.ofunction_declaration)}
	  | {translation_decl} translation_decl	{-> New onamespace_elt.translation(translation_decl.otranslation_declaration)}
	  ;
	
	typographic_decl {-> otypographic_declaration} =
		tab_decl							{-> tab_decl.otypographic_declaration}
		;
	
	import_decl {-> onamespace_elt} =
		import path							{-> New onamespace_elt.import([path.id])}
		;
	
	tab_decl {-> otypographic_declaration} =
		tab_keyword equivalent to number spaces_keyword	{-> New otypographic_declaration.tab_decl(number)}
		;
		
	artifact_decl {-> oartifact_declaration} =
		artifact id colon [expr1]:whole_number_expr
			per_char [expr2]:whole_number_expr
			artifact_stmts					{-> New oartifact_declaration(id, expr1.number,
												expr2.number, [artifact_stmts.ocompatibility_spec])}
		;
	
	whole_number_expr {-> number} =
		number								{-> number}
		;
	
	artifact_stmts {-> ocompatibility_spec*} =
		{multiple} artifact_stmt artifact_stmts
											{-> [artifact_stmt.ocompatibility_spec,
													artifact_stmts.ocompatibility_spec]}
	  | {one} artifact_stmt					{-> [artifact_stmt.ocompatibility_spec]}
	  | {none}								{-> []}
	  ;
	
	artifact_stmt {-> ocompatibility_spec} =
		{assume_stmt} assume_stmt			{-> assume_stmt.ocompatibility_spec}
	  | {tested_stmt} tested_stmt			{-> tested_stmt.ocompatibility_spec}
	  ;
	
	assume_stmt {-> ocompatibility_spec} =
		assume compatible with path colon version_spec	{-> New ocompatibility_spec.assume(
										[path.id], [version_spec.orange_spec])}
		;
	
	tested_stmt {-> ocompatibility_spec} =
		tested with path colon version_spec		{-> New ocompatibility_spec.tested(
										[path.id], [version_spec.orange_spec])}
		;
	
	scope_decl {-> oscope} =
		{public} public						{-> New oscope.public()}
	  | {unspecified}						{-> New oscope.private()}
	  ;
	
	task_decl {-> otask_declaration} =
		scope_decl task id when_clause input_sets output_sets
			procedural_stmts				{-> New otask_declaration(scope_decl.oscope,
												id, [when_clause.oexpr],
												[input_sets.onamed_artifact_set],
												[output_sets.onamed_artifact_set],
												[procedural_stmts.oproc_stmt])}
		;
	
	when_clause {-> oexpr*} =
		when expr							{-> expr.oexpr}  // must be a logical_expr
		;
	
	success_expr {-> osuccess_expr} =
		{succeeded} id succeeded			{-> New osuccess_expr.succeeded(id)}
	  | {failed} id failed					{-> New osuccess_expr.failed(id)}
	  ;
	
	age_expr {-> oage_expr} =
		{newer_than} [newer_id]:id newer than [older_id]:id
											{-> New oage_expr.newer_than(newer_id, older_id)}
	  | {older_than} [older_id]:id older than [newer_id]:id
	  										{-> New oage_expr.older_than(older_id, newer_id)}
	  ;
	
	input_sets {-> onamed_artifact_set*} =
		{multiple} input_set input_sets		{-> [input_set.onamed_artifact_set,
												input_sets.onamed_artifact_set]}
	  | {one} input_set						{-> [input_set.onamed_artifact_set]}
	  | {none}								{-> []}
	  ;
	
	input_set {-> onamed_artifact_set} =
		{named} inputs id artifact_sets		{-> New onamed_artifact_set.named(id,
												[artifact_sets.oartifact_set])}
	  | {anonymous} inputs artifact_sets	{-> New onamed_artifact_set.anonymous(
												[artifact_sets.oartifact_set])}
		;
	
	output_sets {-> onamed_artifact_set*} =
		{multiple} output_set output_sets	{-> [output_set.onamed_artifact_set,
												output_sets.onamed_artifact_set]}
	  | {one} output_set					{-> [output_set.onamed_artifact_set]}
	  | {none}								{-> []}
	  ;
	
	output_set {-> onamed_artifact_set} =
		{named} outputs id artifact_sets	{-> New onamed_artifact_set.named(id,
												[artifact_sets.oartifact_set])}
	  | {anonymous} outputs artifact_sets	{-> New onamed_artifact_set.anonymous(
												[artifact_sets.oartifact_set])}
		;
	  
	artifact_sets {-> oartifact_set*} =
		{multiple} artifact_set comma_char artifact_sets
											{-> [artifact_set.oartifact_set, artifact_sets.oartifact_set]}
	  | {one} artifact_set					{-> [artifact_set.oartifact_set]}
	  ;
	
	// Examples:
	// files XYZ:3.3
	// abc.jar
	// $thisdir/**.java from "my_repo" in my_git
	artifact_set {-> oartifact_set} =
		fileset_spec from [project]:string_literal
		in [repository_id]:id				{-> New oartifact_set(fileset_spec.ostring_literal,
												project.ostring_literal, repository_id)}
		;
	
	fileset_spec {-> ostring_literal} =
		string_literal						{-> string_literal.ostring_literal}
		;
	
	files_decl {-> ofiles_declaration} =
		files [name]:id from string_literal
			in [source]:id prefer_stmt_opt
			files_stmts						{-> New ofiles_declaration(
												prefer_stmt_opt.ofile_preference,
												[files_stmts.ofileset_operation])}
		;
	
	files_stmts {-> ofileset_operation*} =
		{multiple} files_stmt files_stmts	{-> [files_stmt.ofileset_operation,
												files_stmts.ofileset_operation]}
	  | {one} files_stmt					{-> [files_stmt.ofileset_operation]}
	  | {none}								{-> []}
	  ;
	
	files_stmt {-> ofileset_operation} =
		{include} include_stmt				{-> include_stmt.ofileset_operation}
	  | {exclude} exclude_stmt				{-> exclude_stmt.ofileset_operation}
	  ;
	
	prefer_stmt {-> ofile_preference} =
		prefer preference					{-> preference.ofile_preference}
		;
	
	prefer_stmt_opt {-> ofile_preference} =
		{one} prefer_stmt					{-> prefer_stmt.ofile_preference}
	  | {none}								{-> New ofile_preference.no_preference()}
	  ;
	
	preference {-> ofile_preference} =
		{latest} latest version_criteria	{-> version_criteria.ofile_preference}
	  | {version} version_spec				{-> New ofile_preference.version([version_spec.orange_spec])}
	  ;
	
	version_criteria {-> ofile_preference} =
		{compatible} compatible with		{-> New ofile_preference.latest_compatible()}
	  | {tested} tested with				{-> New ofile_preference.latest_tested()}
	  ;
	
	version_spec {-> orange_spec*} =
		{multiple} range_spec per_char version_spec	{-> [range_spec.orange_spec, version_spec.orange_spec]}
	  | {one} range_spec					{-> [range_spec.orange_spec]}
	  ;
	
	range_spec {-> orange_spec} =
		{multiple} [from]:number dash [to]:number
											{-> New orange_spec.range(from, to)}
	  | {one} number						{-> New orange_spec.one(number)}
	  | {all} asterisk						{-> New orange_spec.all()}
	  ;
	
	include_stmt {-> ofileset_operation} =
		include fileset_spec	{-> New ofileset_operation.include(fileset_spec.ostring_literal)}
		;
	
	exclude_stmt {-> ofileset_operation} =
		exclude fileset_spec	{-> New ofileset_operation.exclude(fileset_spec.ostring_literal)}
		;
	
	procedural_stmts {-> oproc_stmt*} =
		{multiple} procedural_stmt procedural_stmts
											{-> [procedural_stmt.oproc_stmt,
												procedural_stmts.oproc_stmt]}
	  | {one} procedural_stmt				{-> [procedural_stmt.oproc_stmt]}
	  | {none}								{-> []}
	  ;
	  
	procedural_stmt {-> oproc_stmt} =
		{func_call} func_call_stmt			{-> func_call_stmt.oproc_stmt}
	  | {on_error} on_error_stmt			{-> on_error_stmt.oproc_stmt}
	  ;
	
	assignment_opt {-> otarget_opt} =
		{id} id eq							{-> New otarget_opt.target(id)}
	  | {nothing} 							{-> New otarget_opt.no_target()}
	  ;
	
	func_call_stmt {-> oproc_stmt} =
		assignment_opt [func_name]:string_literal args_opt
											{-> New oproc_stmt.func_call(
												func_name.ostring_literal,
												[args_opt.oexpr], assignment_opt.otarget_opt)}
		;
	
	args_opt {-> oexpr*} =
		{multiple_args} arg args_opt		{-> [arg.oexpr, args_opt.oexpr]}
	  | {one_arg} arg						{-> [arg.oexpr]}
	  | {preoposition} preposition			{-> []}
	  | {nothing}							{-> []}
	  ;
	
	arg {-> oexpr} =
		expr								{-> expr.oexpr}
		;
	
	on_error_stmt {-> oproc_stmt} =
		on error procedural_stmts_opt		{-> New oproc_stmt.on_error(
												[procedural_stmts_opt.oproc_stmt])}
		;
	
	procedural_stmts_opt {-> oproc_stmt*} =
		{multiple} procedural_stmt procedural_stmts_opt
											{-> [procedural_stmt.oproc_stmt,
												procedural_stmts_opt.oproc_stmt]}
	  | {one} procedural_stmt				{-> [procedural_stmt.oproc_stmt]}
	  | {none}								{-> []}
	  ;
	
	repo_decl {-> orepo_decl} =
		repo [name]:id type [repo_type]:string_literal tcp_scheme_spec_opt
			repo_path_spec userid_spec_opt password_spec_opt
											{-> New orepl_decl(name, repo_type,
												tcp_scheme_spec_opt.ostring_value_opt,
												repo_path_spec.ostring_literal,
												userid_spec_opt.ostring_value_opt,
												password_spec_opt.ostring_value_opt)}
		;
	
	repo_path_spec {-> ostring_literal} =
		path_keyword string_literal			{-> New ostring_literal(string_literal)}
		;
	
	tcp_scheme_spec_opt {-> ostring_value_opt} =
		{specified} tcp_scheme_spec			{-> New ostring_value_opt.specified(tcp_scheme_spec.ostring_literal)}
	  | {unspecified}						{-> New ostring_value_opt.unspecified()}
	  ;
	
	tcp_scheme_spec {-> ostring_literal} =
		scheme string_literal				{-> string_literal.ostring_literal}
		;
	
	userid_spec_opt {-> ostring_value_opt} =
		{specified} userid string_literal		{-> New ostring_value_opt.specified(string_literal.ostring_literal)}
	  | {unspecified}						{-> New ostring_value_opt.unspecified()}
	  ;
	
	password_spec_opt {-> ostring_value_opt} =
		{specified} password string_literal	{-> New ostring_value_opt.specified(string_literal.ostring_literal)}
	  | {unspecified}						{-> New ostring_value_opt.unspecified()}
	  ;
	
	translation_decl {-> otranslation_declaration} =
		shell translation for string_literal
			translation_stmts				{-> New otranslation_declaration(
												string_literal.ostring_literal,
												[translation_stmts.otranslation_stmt])}
		;
	
	translation_stmts {-> otranslation_stmt*} =
		{multiple} translation_stmt translation_stmts
											{-> [translation_stmt.otranslation_stmt,
													translation_stmts.otranslation_stmt]}
	  | {one} translation_stmt				{-> [translation_stmt.otranslation_stmt]}
	  | {none}								{-> []}
	  ;
	
	translation_stmt {-> otranslation_stmt} =
		translate filename [from_string]:string_literal
			to [to_string]:string_literal	{-> New otranslation_stmt.filename(
													from_string.ostring_literal,
													to_string.ostring_literal)}
		;
	
	function_decl {-> ofunction_declaration} =
		function [dabl_name]:id type_spec_seq binds to [target_language]:string_literal
			method [native_name]:string_literal returns type_spec
											{-> New ofunction_declaration(
													dabl_name, [type_spec_seq.otype_spec],
													target_language.ostring_literal,
													native_name.ostring_literal,
													type_spec.otype_spec)}
		;
	
	type_spec_seq {-> otype_spec*} =
		{multiple} type_spec type_spec_separator type_spec_seq
											{-> [type_spec.otype_spec,
												type_spec_separator.otype_spec_separator,
												type_spec_seq.otype_spec]}
	  | {one} type_spec						{-> [type_spec.otype_spec]}
	  ;
	
	type_spec_separator {-> otype_spec_separator} =
		{comma} comma						{-> New otype_spec_separator.comma()}
	  | {id} id  // for defining a preposition that goes before or after a function arg
	  										{-> New otype_spec_separator.id(id)}
	  | {preposition} preposition  // for defining a keyword that goes before or after a function arg
	  										{-> New otype_spec_separator.preposition(
	  											preposition.opreposition)}
	  ;
	
	preposition {-> opreposotion} =
		{from} from							{-> New opreposition.from()}
	  | {to} to								{-> New opreposition.to()}
	  | {in} in								{-> New opreposition.in()}
	  | {for} for							{-> New opreposition.for()}
	  | {with} with							{-> New opreposition.with()}
	  | {when} when							{-> New opreposition.when()}
	  | {on} on								{-> New opreposition.on()}
	  | {of} of								{-> New opreposition.of()}
	  | {than} than							{-> New opreposition.than()}
	  ;
	
	type_spec {-> otype_spec} = 
		{string} string_keyword				{-> New otype_spec.string()}
	  | {int} int_keyword					{-> New otype_spec.int()}
	  | {float} float_keyword				{-> New otype_spec.float()}
	  | {boolean} boolean_keyword			{-> New otype_spec.logical()}
	  ;
	
	path {-> id*} =
		{multiple} id per_char path			{-> [id, path.id]}
	  | {one} id							{-> [id]}
	  ;

	
	// Expressions.
	
	expr {-> oexpr} =
		{logical} logical_expr				{-> logical_expr.oexpr}
	  | {numeric} numeric_expr				{-> numeric_expr.oexpr}
	  | {value} value						{-> value.oexpr}
	  ;
	
	value {-> oexpr} =
		{value} literal						{-> New oexpr.literal(literal.oliteral)}
	  | {variable} id						{-> New oexpr.variable(New ovariable(id))}
	  | {parentheses} left_paren expr right_paren
	  										{-> expr.oexpr}
	  ;
	
	
	// Logical expressions.
	
	logical_expr {-> oexpr} =
		{not} not_expr						{-> not_expr.oexpr}
	  | {success} success_expr				{-> New oexpr.success(success_expr.osuccess_expr)}
	  | {age} age_expr						{-> New oexpr.age(age_expr.oage_expr)}
	  | {op} logical_op_expr				{-> logical_op_expr.oexpr}
	  ;
	
	not_expr {-> oexpr} =
		not_keyword expr					{-> New oexpr.unary(New ounary_op.negation(),
												expr.oexpr)}
		;
	
	logical_op_expr {-> oexpr} =
		[left]:expr logical_operator [right]:expr
											{-> New oexpr.binary(
												left.oexpr, logical_operator.obinary_op,
												right.oexpr)}
		;
	
	logical_operator {-> obinary_op} =
		{and} and_keyword					{-> New obinary_op.and()}
	  | {or} or_keyword						{-> New obinary_op.or()}
	  ;
	
	// Arithmetic expressions.
	
	numeric_expr {-> oexpr} =
		{many} numeric_expr add_op product	{-> New oexpr.binary(
												numeric_expr.oexpr,
												add_op.obinary_op, product.oexpr)}
	  | {one} [first]:product add_op [second]:product
	  										{-> New oexpr.binary(
	  											first.oexpr, add_op.obinary_op,
	  											second.oexpr)}
	  ;
	
	product {-> oexpr} =
		{many} product mult_op value		{-> New oexpr.binary(
												product.oexpr, mult_op.obinary_op,
												value.oexpr)}
	  | {one} [first]:value mult_op [second]:value
	  										{-> New oexpr.binary(
	  											value.oexpr, mult_op.obinary_op,
	  											value.oexpr)}
	  ;
	
	add_op {-> obinary_op} =
		{addition} plus						{-> New obinary_op.plus()}
	  | {subtraction} dash					{-> New obinary_op.minus()}
	  ;
	
	mult_op {-> obinary_op} =
		{multiplication} asterisk			{-> New obinary_op.multiple()}
	  | {division} div						{-> New obinary_op.divide()}
	  ;
	
	// Literals.
	
	literal {-> oliteral} =
		{logic} logical_literal				{-> New oliteral.logic(logical_literal.ologic_literal)}
	  | {string} string_literal				{-> New oliteral.string(string_literal.ostring_literal)}
	  | {numeric} numeric_literal			{-> New oliteral.numeric(numeric_literal.onumeric_literal)}
	  ;
	
	logical_literal {-> ologic_literal} =
		{true} true_keyword					{-> New ologic_literal.true()}
	  | {false} false_keyword				{-> New ologic_literal.false()}
	  ;
	
	numeric_literal {-> onumeric_literal} =
		{int} number						{-> New oliteral.numeric(
													New onumeric_literal.int(number))}
	  | {float} float_number				{-> New oliteral.numeric(
	  												New onumeric_literal.float(float_number))}
	  ;
	
	string_literal {-> ostring_literal} =
		{non_ws} non_ws_char_seq  // this can be a path that references a variable
											{-> New ostring_literal.charseq(non_ws_char_seq)}
	  | {str} string						{-> New ostring_literal.string(string)}
	  | {str2} string2						{-> New ostring_literal.string2(string2)}
	  ;
	

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
Abstract Syntax Tree

	onamespace =
		{namespace_elts} [path]:id* onamespace_elt*;
	
	onamespace_elt =
		{import} id*
	  | {typographic} otypographic_declaration
	  | {artifact} oartifact_declaration
	  | {repo} orepo_decl
	  | {files} ofiles_declaration
	  | {function} ofunction_declaration
	  | {task} otask_declaration
	  | {translation} otranslation_declaration
	  ;

	otypographic_declaration =
		{tab_decl} number;
	
	otype_spec_separator =
		{comma}
	  | {id} id
	  | {preposition} opreposition
	  ;

	opreposition =
		{from}
	  | {to}
	  | {in}
	  | {for}
	  | {with}
	  | {when}
	  | {on}
	  | {of}
	  | {than}
	  ;
	
	oartifact_declaration =
		id [major]:number [minor]:number ocompatibility_spec*
		;
	
	orange_spec =
		{range} [from]:number [to]:number
	  | {one} number
	  | {all}
		;
	
	ocompatibility_spec =
		{assume} id* orange_spec*
	  | {tested} id* orange_spec*
		;

	orepo_decl =
		[name]:id [type]:ostring_literal [scheme]:ostring_value_opt [path]:ostring_literal
			[userid]:ostring_value_opt [password]:ostring_value_opt;

	ostring_value_opt =
		{specified} ostring_literal
	  | {unspecified}
	  ;
	
	ofiles_declaration =
		ofile_preference ofileset_operation*;

	ofile_preference =
		{latest_compatible}
	  | {latest_tested}
	  | {version} orange_spec*
	  | {no_preference}
	  ;
	
	ofileset_operation =
		{include} ostring_literal
	  | {exclude} ostring_literal
	  ;
	
	ofunction_declaration =
		[name]:id otype_spec* [target_language]:ostring_literal [target_name]:ostring_literal
			[return_type]:otype_spec;

	otype_spec = 
		{string}
	  | {int}
	  | {float}
	  | {logical}
	  ;
	
	otask_declaration =
		oscope [name]:id [when]:oexpr*  // each expr must be a logical valued expr
			[input]:onamed_artifact_set*
			[output]:onamed_artifact_set* oproc_stmt*;
	
	oscope =
		{public}
	  | {private}
	  ;
	
	onamed_artifact_set =
		{named} id oartifact_set*
	  | {anonymous} oartifact_set*
	  ;
	
	oartifact_set =
		[fileset_spec]:ostring_literal [project]:ostring_literal [repository_id]:id;
	
	oproc_stmt =
		{func_call} ostring_literal oexpr* otarget_opt
	  | {on_error} oproc_stmt*
	  ;
	
	otarget_opt =
		{target} id
	  | {no_target}
	  ;
	
	otranslation_declaration =
		[os]:ostring_literal otranslation_stmt*;
	
	otranslation_stmt =
		{filename} [from_string]:ostring_literal [to_string]:ostring_literal;
	
	osuccess_expr =
		{succeeded} id
	  | {failed} id
	  ;
	
	oage_expr =
		{newer_than} [newer_id]:id [older_id]:id
	  | {older_than} [older_id]:id [newer_id]:id
	  ;
	
	// Expressions.
	
	ounary_op =
		{negation}
		;
	
	obinary_op =
		{plus}
	  | {minus}
	  | {multiply}
	  | {divide}
	  | {and}
	  | {or}
	  ;
	
	oexpr =
		{literal} oliteral
	  | {variable} ovariable
	  | {unary} ounary_op oexpr
	  | {binary} [operand1]:oexpr obinary_op [operand2]:oexpr
	  | {success} osuccess_expr
	  | {age} oage_expr
	  ;
	
	oliteral =
		{logic} ologic_literal
	  | {string} ostring_literal
	  | {numeric} onumeric_literal
	  ;
	
	ovariable =
		id
		;
	
	ologic_literal =
		{true}
	  | {false}
	  ;
	
	ostring_literal =
		{charseq} non_ws_char_seq
	  | {string} string
	  | {string2} string2
	  ;
	
	onumeric_literal =
		{int} number
	  | {float} float_number
		;
