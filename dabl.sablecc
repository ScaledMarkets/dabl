// SableCC grammar for Dependent Artifact Build Language (DABL).
// For SableCC info, see http://www.sablecc.org/
// For a good SableCC reference, see http://www.natpryce.com/articles/000531.html


Package scaledmarkets.dabl;


Helpers

	any_character = [0x0 .. 0xfffff];
	tab   = 9;
	cr    = 13;
	nl    = 10;
	dollar = '$';
	comma = ',';
	blank = ' ';
	lcletter = ['a' .. 'z'];
	ucletter = ['A' .. 'Z'];
	underscore = '_';
	letter = (lcletter | ucletter | underscore);
	digit = ['0' .. '9'];
	escape = '%' digit digit;
	quote = '"';
	triplequote = '"""';
	slashslash = '//';
	slashslashslash = '///';
	slashstar = '/*';
	starslash = '*/';
	slashslashstar = '//*';
	starslashslash = '*//';
	linetermination = (cr nl | nl);


Tokens

	// Punctuation:
	tab_char = tab;
	nl_char = nl;
	comma_char = comma;
	plus = '+';
	dash = '-';
	asterisk = '*';
	div = '/';
	gt = '>';
	lt = '<';
	ge = '>=';
	le = '<=';
	eq = '=';
	ne = '!=';
	colon = ':';
	semicolon = ';';
	per = '.';
	dotdot = '..';
	qmark = '?';
	def = 'def';
	left_paren = '(';
	right_paren = ')';
	left_cur = '{';
	right_cur = '}';
	left_brack = '[';
	right_brack = ']';
	
	// Variable Length Sequences:
	number = digit+;
	whitespace = (blank)+;
	id = letter ( letter | digit )*;
	non_ws_char_seq = [ any_character - [ quote + comma ] ]*;
	string = quote [ any_character - quote ]* quote;
	string2 = triplequote [ any_character - triplequote ]* triplequote;
	slashslashcomment = slashslash [ any_character - nl ]* nl;
	slashslashslashcomment = slashslashslash [ any_character - nl ]* nl;
	slashstarcomment = slashstar any_character* starslash;
	slashslashstarcomment = slashslashstar any_character* starslashslash;
	
	// Propositional Keywords:
	from = 'from';
	to = 'to';
	in = 'in';
	for = 'for';
	with = 'with';
	when = 'when';
	on = 'on';
	of = 'of';
	than = 'than';
	
	// Non-Propositional Keywords:
	namespace = 'namespace';
	import = 'import';
	tab_keyword = 'tab';
	equivalent = 'equivalent';
	spaces_keyword = 'spaces';
	artifact = 'artifact';
	task = 'task';
	public = 'public';
	repo = 'repo';
	type = 'type';
	git = 'git';
	maven = 'maven';
	svn = 'svn';
	files = 'files';
	shell = 'shell';
	translation = 'translation';
	translate = 'translate';
	filename = 'filename';
	prefer = 'prefer';
	latest = 'latest';
	assume = 'assume';
	compatible = 'compatible';
	tested = 'tested';
	function = 'function';
	binds = 'binds';
	method = 'method';
	returns = 'returns';
	succeeded = 'succeeded';
	failed = 'failed';
	newer = 'newer';
	older = 'older';
	inputs = 'inputs';
	outputs = 'outputs';
	path_keyword = 'path';
	scheme = 'scheme';
	error = 'error';
	string_keyword = 'string';
	int_keyword = 'int';
	float_keyword = 'float';
	boolean_keyword = 'boolean';
	not_keyword = 'not';
	and_keyword = 'and';
	or_keyword = 'or';
	include = 'include';
	exclude = 'exclude';
	true_keyword = 'true';
	false_keyword = 'false';
	userid = 'userid';
	password = 'password';


Ignored Tokens

	slashslashcomment,
	slashslashslashcomment,
	slashstarcomment,
	slashslashstarcomment,
	whitespace;


// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
Productions

	specification {-> onamespace} =
		{namespace_decl} namespace_decl spec_elt_seq	{-> New onamespace.namespace_elts(
															[namespace_decl.id],
															[spec_elt_seq.onamespace_elt])};
	
	namespace_decl {-> id*} =
		namespace path									{-> [path.id]};
	
	spec_elt_seq {-> onamespace_elt*} =
		{multiple} spec_elt spec_elt_seq				{-> [spec_elt.onamespace_elt, spec_elt_seq.onamespace_elt]}
	  | {one} spec_elt									{-> [spec_elt.onamespace_elt]}
	  ;
	 
	spec_elt {-> onamespace_elt} =
		{import_decl} import_decl						{-> import_decl.onamespace_elt}
	  | {typographic_decl} typographic_decl				{-> New onamespace_elt.typographic(typographic_decl.otypographic_declaration)}
	  | {artifact_decl} artifact_decl					{-> }
	  | {task_decl} task_decl							{-> }
	  | {repo_decl} repo_decl							{-> }
	  | {files_decl} files_decl							{-> }
	  | {function_decl} function_decl					{-> }
	  | {translation_decl} translation_decl				{-> }
	  ;
	
	typographic_decl {-> otypographic_declaration} =
		tab_decl					{-> tab_decl.otypographic_declaration}
		;
	
	import_decl {-> onamespace_elt} =
		import path					{-> New onamespace_elt.import([path.id])}
		;
	
	tab_decl {-> otypographic_declaration} =
		tab_keyword equivalent to number spaces_keyword	{-> New otypographic_declaration.tab_decl(number)}
		;
		
	artifact_decl {-> oartifact_declaration} =
		artifact id colon [expr1]:whole_number_expr
			per [expr2]:whole_number_expr
			artifact_stmts			{-> New oartifact_declaration(id, expr1.number,
										expr2.number, [artifact_stmts.ocompatibility_spec]}
		;
	
	whole_number_expr {-> number} =
		number						{-> number}
		;
	
	artifact_stmts {-> ocompatibility_spec*} =
		{multiple} artifact_stmt artifact_stmts	{-> [artifact_stmt.ocompatibility_spec,
													artifact_stmts.ocompatibility_spec]}
	  | {one} artifact_stmt			{-> [artifact_stmt.ocompatibility_spec]}
	  | {none}						{-> []}
	  ;
	
	artifact_stmt {-> ocompatibility_spec} =
		{assume_stmt} assume_stmt	{-> assume_stmt.ocompatibility_spec}
	  | {tested_stmt} tested_stmt	{-> assume_stmt.ocompatibility_spec}
	  ;
	
	assume_stmt {-> ocompatibility_spec} =
		assume compatible with path colon version_spec	{-> New ocompatibility_spec.assume(
										[path.id], version_spec.orange_spec)}
		;
	
	tested_stmt {-> ocompatibility_spec} =
		tested with path colon version_spec	{-> New ocompatibility_spec.tested(
										[path.id], version_spec.orange_spec)}
		;
	
	scope_decl {-> oscope} =
		{public} public				{-> New oscope.public()}
	  | {unspecified}				{-> New oscope.private()}
	  ;
	
	task_decl {-> otask_declaration} =
		scope_decl task id when_clause input_sets output_sets
			procedural_stmts		{-> New otask_declaration(scope_decl.oscope,
										id, when_clause.ological_expr,
										[input_sets.onamed_artifact_set],
										[output_sets.onamed_artifact_set],
										[procedural_stmts.oproc_stmt])}
		;
	
	when_clause {-> ological_expr*} =
		when expr					{-> expr.oexpr}  // must be a logical_expr
		;
	
	success_expr {-> osuccess_expr} =
		{succeeded} id succeeded	{-> New osuccess_expr.succeeded(id)}
	  | {failed} id failed			{-> New osuccess_expr.failed(id)}
	  ;
	
	age_expr {-> oage_expr} =
		{newer_than} [newer_id]:id newer than [older_id]:id
									{-> New oage_expr.newer_than(newer_id, older_id)}
	  | {older_than} [older_id]:id older than [newer_id]:id
	  								{-> New oage_expr.older_than(older_id, newer_id)}
	  ;
	
	string_value {-> ostring_value} =
		{non_ws} non_ws_char_seq  // this can be a path that references a variable
									{-> New ostring_value.charseq(non_ws_char_seq)}
	  | {str} string				{-> New ostring_value.string(string)}
	  | {str2} string2				{-> New ostring_value.string2(string2)}
	  ;
	
	input_sets {-> onamed_artifact_set*} =
		{multiple} input_set input_sets		{-> [input_set.onamed_artifact_set,
												input_sets.onamed_artifact_set]}
	  | {one} input_set				{-> [input_set.onamed_artifact_set]}
	  | {none}						{-> []}
	  ;
	
	input_set {-> onamed_artifact_set} =
		{named} inputs id artifact_sets		{-> New onamed_artifact_set.named(id,
												[artifact_sets.oartifact_set]}
	  | {anonymous} inputs artifact_sets	{-> New onamed_artifact_set.anonymous(
												[artifact_sets.oartifact_set]}
		;
	
	output_sets {-> onamed_artifact_set*} =
		{multiple} output_set output_sets		{-> [output_set.onamed_artifact_set,
												output_sets.onamed_artifact_set]}
	  | {one} output_set				{-> [output_set.onamed_artifact_set]}
	  | {none}							{-> []}
	  ;
	
	output_set {-> onamed_artifact_set} =
		{named} outputs id artifact_sets	{-> New onamed_artifact_set.named(id,
												[artifact_sets.oartifact_set]}
		{anonymous} outputs artifact_sets	{-> New onamed_artifact_set.anonymous(
												[artifact_sets.oartifact_set]}
		;
	  
	artifact_sets {-> oartifact_set*} =
		{multiple} artifact_set comma_char artifact_sets
											{-> [artifact_set.oartifact_set, artifact_sets.oartifact_set]}
	  | {one} artifact_set					{-> [artifact_set.oartifact_set]}
	  ;
	
	// Examples:
	// files XYZ:3.3
	// abc.jar
	// $thisdir/**.java from "my_repo" in my_git
	artifact_set {-> oartifact_set} =
		fileset_spec from [project]:string_value
		in [repository_id]:id				{-> New oartifact_set(fileset_spec.ostring_value,
												New ostring_value(string_value), id)}
		;
	
	fileset_spec {-> ostring_value} =
		string_value						{-> New ostring_value(string_value)}
		;
	
	files_decl {-> ofiles_declaration} =
		files [name]:id from string_value
			in [source]:id prefer_stmt_opt
			files_stmts						{-> New ofiles_declaration(
												prefer_stmt_opt.ofile_preference,
												[files_stmts.ofileset_operation]}
		;
	
	files_stmts {-> ofileset_operation*} =
		{multiple} files_stmt files_stmts	{-> [files_stmt.ofileset_operation,
												files_stmts.ofileset_operation]}
	  | {one} files_stmt					{-> [files_stmt.ofileset_operation]}
	  | {none}								{-> []}
	  ;
	
	files_stmt {-> ofileset_operation} =
	  | {include} include_stmt				{-> include_stmt.ofileset_operation}
	  											
	  | {exclude} exclude_stmt				{-> exclude_stmt.ofileset_operation}
	  ;
	
	prefer_stmt {-> ofile_preference} =
		prefer preference					{-> preference.ofile_preference}
		;
	
	prefer_stmt_opt {-> ofile_preference} =
		{one} prefer_stmt					{-> prefer_stmt.ofile_preference}
	  | {none}								{-> New ofile_preference.no_preference()}
	  ;
	
	preference {-> ofile_preference} =
		{latest} latest version_criteria	{-> version_criteria.ofile_preference}
	  | {version} version_spec				{-> New ofile_preference.version([version_spec.orange_spec])}
	  ;
	
	version_criteria {-> ofile_preference} =
		{compatible} compatible with		{-> New ofile_preference.latest_compatible()}
	  | {tested} tested with				{-> New ofile_preference.latest_tested()}
	  ;
	
	version_spec {-> orange_spec*} =
		{multiple} range_spec per version_spec	{-> [range_spec.orange_spec, version_spec.orange_spec]}
	  | {one} range_spec					{-> [range_spec.orange_spec]}
	  ;
	
	range_spec {-> orange_spec} =
		{multiple} [from]:number dash [to]:number
											{-> New orange_spec.range(from, to)}
	  | {one} number						{-> New orange_spec.one(number)}
	  | {all} asterisk						{-> New orange_spec.all()}
	  ;
	
	include_stmt {-> ofileset_operation} =
		include fileset_spec	{-> New ofileset_operation.include(fileset_spec.ostring_value)}
		;
	
	exclude_stmt {-> ofileset_operation} =
		exclude fileset_spec	{-> New ofileset_operation.exclude(fileset_spec.ostring_value)}
		;
	
	procedural_stmts {-> oproc_stmt*} =
		{multiple} procedural_stmt procedural_stmts
											{-> [procedural_stmt.oproc_stmt,
												procedural_stmts.oproc_stmt]}
	  | {one} procedural_stmt				{-> [procedural_stmt.oproc_stmt]}
	  | {none}								{-> []}
	  ;
	  
	procedural_stmt {-> oproc_stmt} =
	  | {func_call} func_call_stmt			{-> func_call_stmt.oproc_stmt}
	  | {on_error} on_error_stmt			{-> on_error_stmt.oproc_stmt}
	  ;
	
	assignment_opt {-> otarget_opt} =
		{id} id eq							{-> New otarget_opt.target(id)}
	  | {nothing} 							{-> New otarget_opt.no_target()}
	  ;
	
	func_call_stmt {-> oproc_stmt} =
		assignment_opt [func_name]:string_value args_opt
											{-> New oproc_stmt.func_call(
												func_name.ostring_value,
												[args_opt.oexpr], assignment_opt.otarget_opt)}
		;
	
	args_opt {-> oexpr*} =
		{multiple_args} arg args_opt		{-> [arg.oexpr, args_opt.oexpr]}
	  | {one_arg} arg						{-> [arg.oexpr]}
	  | {preoposition} preposition			{-> }
	  | {nothing}							{-> }
	  ;
	
	arg {-> oexpr} =
		expr								{-> expr.oexpr)
		;
	
	on_error_stmt {-> oproc_stmt} =
		on error procedural_stmts_opt		{-> New oproc_stmt.on_error(
												[procedural_stmts_opt.oproc_stmt])}
		;
	
	procedural_stmts_opt {-> oproc_stmt*} =
		{multiple} procedural_stmt procedural_stmts_opt
											{-> [procedural_stmt.oproc_stmt,
												procedural_stmts_opt.oproc_stmt]}
	  | {one} procedural_stmt				{-> [procedural_stmt.oproc_stmt]}
	  | {none}								{-> []}
	  ;
	
	repo_decl {-> orepo_decl} =
		repo [name]:id type [repo_type]:string_value tcp_scheme_spec_opt
			repo_path_spec userid_spec_opt password_spec_opt
											{-> New orepl_decl(name, repo_type,
												tcp_scheme_spec_opt.ostring_value_opt,
												repo_path_spec.ostring_value,
												userid_spec_opt.ostring_value_opt,
												password_spec_opt.ostring_value_opt)}
		;
	
	repo_path_spec {-> ostring_value} =
		path_keyword string_value			{-> New ostring_value(string_value)}
		;
	
	tcp_scheme_spec_opt {-> ostring_value_opt} =
		{specified} tcp_scheme_spec			{-> New ostring_value_opt.specified(tcp_scheme_spec.ostring_value)}
	  | {unspecified}						{-> New ostring_value_opt.unspecified()}
	  ;
	
	tcp_scheme_spec {-> ostring_value} =
		scheme string_value					{-> string_value.ostring_value}
		;
	
	userid_spec_opt {-> ostring_value_opt} =
		{specified} userid string_value		{-> New ostring_value_opt.specified(string_value.ostring_value)}
	  | {unspecified}						{-> New ostring_value_opt.unspecified()}
	  ;
	
	password_spec_opt {-> ostring_value_opt} =
		{specified} password string_value	{-> New ostring_value_opt.specified(string_value.ostring_value)}
	  | {unspecified}						{-> New ostring_value_opt.unspecified()}
	  ;
	
	translation_decl {-> otranslation_declaration} =
		shell translation for string_value
			translation_stmts				{-> New otranslation_declaration(
												string_value.ostring_value,
												[translation_stmts.otranslation_stmt])}
		;
	
	translation_stmts {-> otranslation_stmt*} =
		{multiple} translation_stmt translation_stmts
											{-> [translation_stmt.otranslation_stmt,
													translation_stmts.otranslation_stmt]}
	  | {one} translation_stmt				{-> [translation_stmt.otranslation_stmt]}
	  | {none}								{-> []}
	  ;
	
	translation_stmt {-> otranslation_stmt} =
		translate filename [from_string]:string_value
			to [to_string]:string_value		{-> New otranslation_stmt.filename(
													from_string.ostring_value,
													to_string.ostring_value)}
		;
	
	function_decl {-> ofunction_declaration} =
		function [dabl_name]:id type_spec_seq binds to [target_language]:string_value
			method [native_name]:string_value returns type_spec
											{-> New ofunction_declaration(
													dabl_name, [type_spec_seq.otype_spec],
													target_language.ostring_value,
													native_name.ostring_value,
													type_spec.otype_spec)}
		;
	
	type_spec_seq {-> otype_spec*} =
		{multiple} type_spec type_spec_seq	{-> [type_spec.otype_spec, type_spec_seq.otype_spec]}
	  | {one} type_spec						{-> [type_spec.otype_spec]}
	  | {id} id  // for defining a preposition that goes before or after a function arg
	  | {preposition} preposition  // for defining a keyword that goes before or after a function arg
	  ;
	
	preposition {-> } =
		{from} from
	  | {to} to
	  | {in} in
	  | {for} for
	  | {with} with
	  | {when} when
	  | {on} on
	  | {of} of
	  | {than} than
	  ;
	
	type_spec {otype_spec} = 
		{string} string_keyword				{-> New otype_spec.string()}
	  | {int} int_keyword					{-> New otype_spec.int()}
	  | {float} float_keyword				{-> New otype_spec.float()}
	  | {boolean} boolean_keyword			{-> New otype_spec.logical()}
	  ;
	
	path {-> id*} =
		{multiple} id per path				{-> [id, path.id]}
	  | {one} id							{-> [id]}
	  ;

	
	// Logical expressions.
	
	logical_expr {-> ological_expr} =
		{not} not_expr						{-> New ological_expr.not(not_expr.onot_expr)}
	  | {success} success_expr				{-> New ological_expr.success(success_expr.osuccess_expr)}
	  | {age} age_expr						{-> New ological_expr.age(age_expr.oage_expr)}
	  | {op} logical_op_expr				{-> New ological_expr.op(logical_op_expr.ologic_op_expr)}
	  | {literal} logical_literal			{-> New ological_expr.literal(logical_literal.ologic_literal)}
	  ;
	
	logical_literal {-> ologic_literal} =
		{true} true_keyword					{-> New ologic_literal.true()}
	  | {false} false_keyword				{-> New ologic_literal.false()}
	  ;
	
	not_expr {-> onot_expr} =
		not_keyword expr					{-> New onot_expr(expr.oexpr)}
		;
	
	logical_op_expr {-> ologic_op_expr} =
		[left]:logical_expr logical_operator [right]:logical_expr
											{-> New ologic_op_expr(left.ological_expr,
													logical_operator.ologic_op,
													right.ological_expr)}
		;
	
	logical_operator {-> ologic_op} =
		{and} and_keyword					{-> New ologic_op.and()}
	  | {or} or_keyword						{-> New ologic_op.or()}
	  ;
	
	// Arithmetic expressions.
	
	numeric_expr =
		{many} numeric_expr add_op product
	  | {one} product add_op product
	  ;
	
	product =
		{many} product mult_op numeric_value
	  | {one} numeric_value mult_op numeric_value
	  ;
	
	numeric_value =
		{value} number
	  | {parentheses} left_paren numeric_expr right_paren
	  ;
	
	add_op =
		{addition} plus
	  | {subtraction} dash
	  ;
	
	mult_op =
		{multiplication} asterisk
	  | {division} div
	  ;
	
	// Other expression types.
	
	string_expr =
		string_value
		;
	
	// General expressions.
	
	expr {-> oexpr} =
		{string} string_expr
	  | {numeric} numeric_expr
	  | {logical} logical_expr
	  | {variable} id
	  ;
	

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
Abstract Syntax Tree

	onamespace =
		{namespace_elts} [path]:id* onamespace_elt*;
	
	onamespace_elt =
		{import} id*
	  | {typographic} otypographic_declaration
	  | {artifact} oartifact_declaration
	  | {repo} orepo_decl
	  | {file} ofiles_declaration
	  | {function} ofunction_declaration
	  | {task} otask_declaration
	  | {translation} otranslation_declaration
	  ;

	otypographic_declaration =
		{tab_decl} number;

	oartifact_declaration =
		id [major]:number [minor]:number ocompatibility_spec*
		;
	
	orange_spec =
		{range} [from]:number [to]:number
	  | {one} number
	  | {all}
		;
	
	ocompatibility_spec =
		{assume} id* orange_spec
	  | {tested} id* orange_spec
		;

	orepo_decl =
		[name]:id [type]:ostring_value [scheme]:ostring_value_opt [path]:ostring_value
			[userid]:ostring_value_opt [password]:ostring_value_opt;

	ostring_value_opt =
		{specified} ostring_value
	  | {unspecified}
	  ;
	
	ofiles_declaration =
		ofile_preference ofileset_operation*;

	ofile_preference =
		{latest_compatible}
	  | {latest_tested}
	  | {version} orange_spec*
	  | {no_preference}
	  ;
	
	ofileset_operation =
		{include} ostring_value
	  | {exclude} ostring_value
	  ;
	
	ofunction_declaration =
		[name]:id otype_spec* [target_language]:ostring_value [target_name]:ostring_value
			[return_type]:otype_spec;

	otype_spec = 
		{string}
	  | {int}
	  | {float}
	  | {logical}
	  ;
	
	otask_declaration =
		oscope [name]:id [when]:oexpr* [input]:onamed_artifact_set*
			[output]:onamed_artifact_set* oproc_stmt*;
			// when must be a ological_expr
	
	oscope =
		{public}
	  | {private}
	  ;
	
	onamed_artifact_set =
		{named} id oartifact_set*
	  | {anonymous} oartifact_set*
	  ;
	
	oartifact_set =
		[fileset_spec]:ostring_value [project]:ostring_value [repository_id]:id;
	
	oproc_stmt =
		{func_call} ostring_value expr* otarget_opt
	  | {on_error} oproc_stmt*
	  ;
	
	otarget_opt =
		{target} id
	  | {no_target}
	  ;
	
	otranslation_declaration =
		[os]:ostring_value otranslation_stmt*;
	
	otranslation_stmt =
		{filename} [from_string]:ostring_value [to_string]:ostring_value;
	
	osuccess_expr =
		{succeeded} id
	  | {failed} id
	  ;
	
	oage_expr =
		{newer_than} [newer_id]:id [older_id]:id
	  | {older_than} [older_id]:id [newer_id]:id
	  ;
	
	onot_expr =
		oexpr;
	
	ological_expr =
		{not} onot_expr
	  | {success} osuccess_expr
	  | {age} oage_expr
	  | {op} ologic_op_expr
	  | {literal} ologic_literal
	  ;
	
	ologic_op_expr =
		[left]:oexpr logic_op [right]:oexpr
		;
	
	ologic_op =
		{and}
	  | {or}
	  ;
	
	ologic_literal =
		{true}
	  | {false}
	  ;
	
	onumeric_expr =
		{many} [operand1]:onumeric_expr oadd_op [operand2]:oproduct
	  | {one} [operand1]:oproduct oadd_op [operand2]:oproduct
		;
	
	oproduct =
		{many} [operand1]:oproduct omult_op [operand2]:onumeric_expr
		{one} [operand1]:onumeric_expr omult_op [operand2]:onumeric_expr
		;
	
	onumeric_value =
		{value} number
	  | {parenthetic_expr} numeric_expr
	  | {variable} id
	  ;
	
	oadd_op =
		{plus}
	  | {minus
	  ;
	
	omult_op =
		{multiply}
	  | {divide}
	  ;
	
	oexpr =
		{string} ostring_value
	  | ....
	  ;
	
	ostring_value =
		{charseq} non_ws_char_seq
		{string} string
		{string2} string2
